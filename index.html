<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>PINEWOOD DERBY // Race Engineering Lab</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Rajdhani:wght@400;500;600;700&family=Share+Tech+Mono&display=swap" rel="stylesheet">
<style>
  @keyframes scanline {
    0% { transform: translateY(-100%); }
    100% { transform: translateY(100vh); }
  }
  @keyframes pulse { 0%,100% { opacity: 1; } 50% { opacity: 0.4; } }
  @keyframes glow { 0%,100% { box-shadow: 0 0 8px var(--race-red), 0 0 20px rgba(220,38,38,0.3); } 50% { box-shadow: 0 0 15px var(--race-red), 0 0 40px rgba(220,38,38,0.5); } }
  @keyframes slideIn { from { opacity:0; transform: translateY(8px); } to { opacity:1; transform: translateY(0); } }
  @keyframes dataStream { 0% { background-position: 0% 0%; } 100% { background-position: 200% 0%; } }
  @keyframes revMeter { 0% { width: 0%; } 100% { width: var(--target-width); } }
  @keyframes borderTrace {
    0% { background-position: 0% 0%; }
    100% { background-position: 200% 0%; }
  }
  @keyframes fadeInStagger { from { opacity:0; transform: translateX(-10px); } to { opacity:1; transform: translateX(0); } }
  @keyframes hud-flicker {
    0%, 95%, 100% { opacity: 1; }
    96% { opacity: 0.8; }
    97% { opacity: 1; }
    98% { opacity: 0.6; }
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  :root {
    --bg-deep: #0a0a0f;
    --bg-panel: #0d0d14;
    --bg-card: #12121c;
    --bg-card-hover: #1a1a28;
    --race-red: #dc2626;
    --race-red-dim: #991b1b;
    --amber: #f59e0b;
    --amber-dim: #92400e;
    --green: #22c55e;
    --green-dim: #166534;
    --blue: #3b82f6;
    --text: #e8e8f0;
    --text-dim: #6b6b80;
    --text-muted: #44445a;
    --border: #1e1e2e;
    --border-light: #2a2a3e;
    --carbon-1: #101018;
    --carbon-2: #0e0e16;
  }

  /* Carbon fiber pattern */
  body {
    font-family: 'Rajdhani', sans-serif;
    background: var(--bg-deep);
    color: var(--text);
    overflow: hidden;
    height: 100vh;
    background-image:
      linear-gradient(45deg, var(--carbon-1) 25%, transparent 25%),
      linear-gradient(-45deg, var(--carbon-1) 25%, transparent 25%),
      linear-gradient(45deg, transparent 75%, var(--carbon-2) 75%),
      linear-gradient(-45deg, transparent 75%, var(--carbon-2) 75%);
    background-size: 4px 4px;
    background-position: 0 0, 0 2px, 2px -2px, -2px 0px;
  }

  #app {
    display: grid;
    grid-template-columns: 1fr 400px;
    grid-template-rows: auto 1fr;
    height: 100vh;
  }

  /* ======== HEADER ======== */
  header {
    grid-column: 1 / -1;
    background: linear-gradient(180deg, #111119 0%, #0d0d14 100%);
    padding: 0 24px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    border-bottom: 1px solid var(--border);
    height: 64px;
    position: relative;
    overflow: hidden;
  }
  header::before {
    content: '';
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    height: 2px;
    background: linear-gradient(90deg, transparent, var(--race-red), var(--amber), var(--race-red), transparent);
    animation: dataStream 3s linear infinite;
    background-size: 200% 100%;
  }
  header::after {
    content: '';
    position: absolute;
    top: 0;
    right: 200px;
    width: 120px;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(220,38,38,0.03), transparent);
    transform: skewX(-20deg);
  }

  .header-left {
    display: flex;
    align-items: center;
    gap: 16px;
  }
  .header-flag {
    width: 36px;
    height: 36px;
    display: grid;
    grid-template-columns: 1fr 1fr;
    grid-template-rows: 1fr 1fr;
    transform: rotate(-5deg);
    border: 1px solid var(--border-light);
    flex-shrink: 0;
  }
  .header-flag div:nth-child(1),
  .header-flag div:nth-child(4) { background: #fff; }
  .header-flag div:nth-child(2),
  .header-flag div:nth-child(3) { background: #1a1a1a; }

  header h1 {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 1.8rem;
    font-weight: 400;
    letter-spacing: 4px;
    line-height: 1;
    text-transform: uppercase;
  }
  header h1 .red { color: var(--race-red); }
  header h1 .dim {
    color: var(--text-dim);
    font-family: 'Share Tech Mono', monospace;
    font-size: 0.65rem;
    letter-spacing: 3px;
    display: block;
    margin-top: 2px;
  }

  .header-telemetry {
    display: flex;
    align-items: center;
    gap: 24px;
  }

  .weight-gauge {
    display: flex;
    align-items: center;
    gap: 12px;
  }
  .weight-gauge-label {
    font-family: 'Share Tech Mono', monospace;
    font-size: 0.7rem;
    color: var(--text-dim);
    text-transform: uppercase;
    letter-spacing: 2px;
  }
  .weight-gauge-value {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 1.6rem;
    letter-spacing: 2px;
    min-width: 120px;
    text-align: right;
  }
  .weight-gauge-bar {
    width: 180px;
    height: 8px;
    background: var(--bg-card);
    border: 1px solid var(--border);
    position: relative;
    overflow: hidden;
  }
  .weight-gauge-bar::before {
    content: '';
    position: absolute;
    top: 0; bottom: 0; left: 0; right: 0;
    background: repeating-linear-gradient(90deg, transparent, transparent 8px, rgba(255,255,255,0.03) 8px, rgba(255,255,255,0.03) 9px);
  }
  .weight-gauge-fill {
    height: 100%;
    transition: width 0.6s cubic-bezier(0.16,1,0.3,1), background 0.3s;
    position: relative;
  }
  .weight-gauge-fill::after {
    content: '';
    position: absolute;
    right: 0;
    top: -2px;
    bottom: -2px;
    width: 2px;
    background: #fff;
    box-shadow: 0 0 6px #fff;
  }

  .status-light {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: var(--green);
    box-shadow: 0 0 6px var(--green);
    animation: pulse 2s ease-in-out infinite;
  }
  .status-light.warning { background: var(--amber); box-shadow: 0 0 6px var(--amber); }
  .status-light.danger { background: var(--race-red); box-shadow: 0 0 6px var(--race-red); }

  .header-cog {
    display: flex;
    align-items: center;
    gap: 10px;
    padding-left: 20px;
    border-left: 1px solid var(--border);
  }
  .header-cog-label {
    font-family: 'Share Tech Mono', monospace;
    font-size: 0.7rem;
    color: var(--text-dim);
    text-transform: uppercase;
    letter-spacing: 2px;
  }
  .header-cog-value {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 1.1rem;
    letter-spacing: 1px;
    color: var(--amber);
    white-space: nowrap;
  }

  /* ======== VIEWPORT ======== */
  #viewport {
    position: relative;
    background: #12141c;
    overflow: hidden;
  }
  #viewport::before {
    content: '';
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    background:
      linear-gradient(rgba(40,100,180,0.04) 1px, transparent 1px),
      linear-gradient(90deg, rgba(40,100,180,0.04) 1px, transparent 1px);
    background-size: 40px 40px;
    pointer-events: none;
    z-index: 1;
  }
  #viewport::after {
    content: '';
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    background: radial-gradient(ellipse at center, transparent 40%, rgba(0,0,0,0.6) 100%);
    pointer-events: none;
    z-index: 2;
  }

  #three-canvas { width: 100%; height: 100%; display: block; touch-action: none; }

  /* Scanline overlay */
  .scan-overlay {
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    pointer-events: none;
    z-index: 3;
    overflow: hidden;
  }
  .scan-overlay::before {
    content: '';
    position: absolute;
    top: 0; left: 0; right: 0;
    height: 4px;
    background: linear-gradient(180deg, rgba(220,38,38,0.15), transparent);
    animation: scanline 4s linear infinite;
    filter: blur(1px);
  }

  /* HUD corner brackets */
  .hud-bracket {
    position: absolute;
    width: 20px;
    height: 20px;
    z-index: 5;
    pointer-events: none;
  }
  .hud-bracket.tl { top: 12px; left: 12px; border-top: 2px solid var(--race-red); border-left: 2px solid var(--race-red); }
  .hud-bracket.tr { top: 12px; right: 12px; border-top: 2px solid var(--race-red); border-right: 2px solid var(--race-red); }
  .hud-bracket.bl { bottom: 12px; left: 12px; border-bottom: 2px solid var(--race-red); border-left: 2px solid var(--race-red); }
  .hud-bracket.br { bottom: 12px; right: 12px; border-bottom: 2px solid var(--race-red); border-right: 2px solid var(--race-red); }

  /* Top-left: View presets */
  .viewport-presets {
    position: absolute;
    top: 16px;
    left: 40px;
    z-index: 5;
    display: flex;
    gap: 6px;
    align-items: center;
  }
  .viewport-presets .preset-reset {
    background: rgba(10,10,15,0.8);
    backdrop-filter: blur(8px);
    border: 1px solid var(--border);
    color: var(--text-dim);
    padding: 6px 12px;
    cursor: pointer;
    font-family: 'Rajdhani', sans-serif;
    font-size: 0.72rem;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 2px;
    transition: all 0.2s;
  }
  .viewport-presets .preset-reset:hover {
    color: var(--text);
    border-color: var(--race-red);
    background: rgba(220,38,38,0.1);
  }
  .viewport-presets .preset-group {
    display: flex;
  }
  .viewport-presets .preset-group button {
    background: rgba(10,10,15,0.8);
    backdrop-filter: blur(8px);
    border: 1px solid var(--border);
    color: var(--text-dim);
    padding: 6px 14px;
    cursor: pointer;
    font-family: 'Rajdhani', sans-serif;
    font-size: 0.72rem;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 2px;
    transition: all 0.2s;
    margin-left: -1px;
  }
  .viewport-presets .preset-group button:first-child {
    margin-left: 0;
    border-radius: 3px 0 0 3px;
  }
  .viewport-presets .preset-group button:last-child {
    border-radius: 0 3px 3px 0;
  }
  .viewport-presets .preset-group button:hover {
    color: var(--text);
    border-color: var(--race-red);
    background: rgba(220,38,38,0.1);
    z-index: 1;
  }
  .viewport-presets .preset-group button.active {
    color: var(--green);
    border-color: var(--green);
    background: rgba(74,222,128,0.1);
    z-index: 1;
  }

  /* Top-right: Tools */
  .viewport-tools {
    position: absolute;
    top: 16px;
    right: 40px;
    z-index: 5;
    display: flex;
    gap: 6px;
    align-items: center;
  }
  .viewport-tools button {
    background: rgba(10,10,15,0.8);
    backdrop-filter: blur(8px);
    border: 1px solid var(--border);
    color: var(--text-dim);
    padding: 6px 14px;
    cursor: pointer;
    font-family: 'Rajdhani', sans-serif;
    font-size: 0.72rem;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 2px;
    transition: all 0.2s;
  }
  .viewport-tools button:hover {
    color: var(--text);
    border-color: var(--race-red);
    background: rgba(220,38,38,0.1);
  }
  .viewport-tools .spin-toggle.active {
    color: var(--green);
    border-color: var(--green);
    background: rgba(74,222,128,0.1);
  }
  .viewport-tools #view-mode-btn {
    background: rgba(220,38,38,0.15);
    border-color: var(--race-red-dim);
    color: var(--race-red);
    font-weight: 700;
    text-shadow: 0 0 8px rgba(220,38,38,0.4);
  }
  .viewport-tools #view-mode-btn:hover {
    color: #fff;
    border-color: var(--race-red);
    background: rgba(220,38,38,0.25);
    box-shadow: 0 0 12px rgba(220,38,38,0.3);
  }

  /* Top-right: Designs button */
  .viewport-designs-btn {
    position: absolute;
    bottom: 16px;
    right: 16px;
    z-index: 5;
    background: rgba(10,10,15,0.8);
    backdrop-filter: blur(8px);
    border: 1px solid var(--border);
    color: var(--text-dim);
    padding: 6px 14px;
    cursor: pointer;
    font-family: 'Rajdhani', sans-serif;
    font-size: 0.72rem;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 2px;
    transition: all 0.2s;
  }
  .viewport-designs-btn:hover {
    color: var(--text);
    border-color: var(--race-red);
    background: rgba(220,38,38,0.1);
  }

  .viewport-model-label {
    position: absolute;
    bottom: 16px;
    left: 40px;
    z-index: 5;
    text-align: left;
    font-family: 'Share Tech Mono', monospace;
    animation: hud-flicker 8s infinite;
  }
  .viewport-model-label .model-name {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 1.1rem;
    letter-spacing: 3px;
    color: var(--text-dim);
  }

  /* ======== PANEL ======== */
  #panel {
    background: var(--bg-panel);
    overflow-y: auto;
    border-left: 1px solid var(--border);
    position: relative;
  }
  #panel::before {
    content: '';
    position: absolute;
    top: 0; left: 0;
    width: 1px;
    height: 100%;
    background: linear-gradient(180deg, var(--race-red), transparent 30%, transparent 70%, var(--race-red));
    z-index: 2;
  }

  .tabs {
    display: flex;
    border-bottom: 1px solid var(--border);
    background: var(--bg-deep);
    position: sticky;
    top: 0;
    z-index: 10;
  }
  .tabs button {
    flex: 1;
    padding: 14px 4px 12px;
    background: none;
    border: none;
    color: var(--text-dim);
    cursor: pointer;
    font-family: 'Rajdhani', sans-serif;
    font-size: 0.78rem;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 1.5px;
    border-bottom: 2px solid transparent;
    transition: all 0.25s;
    position: relative;
  }
  .tabs button:hover { color: var(--text); }
  .tabs button.active {
    color: #fff;
    border-bottom-color: var(--race-red);
    background: rgba(220,38,38,0.06);
  }
  .tabs button.active::after {
    content: '';
    position: absolute;
    bottom: 0;
    left: 50%;
    transform: translateX(-50%);
    width: 30px;
    height: 2px;
    background: var(--race-red);
    box-shadow: 0 0 10px var(--race-red), 0 0 20px rgba(220,38,38,0.3);
  }
  .tab-content { padding: 16px; display: none; }
  .tab-content.active {
    display: block;
    animation: slideIn 0.3s ease-out;
  }

  .section { margin-bottom: 20px; }
  .section h3 {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 0.95rem;
    color: var(--race-red);
    margin-bottom: 12px;
    letter-spacing: 3px;
    text-transform: uppercase;
    padding-bottom: 6px;
    border-bottom: 1px solid var(--border);
    display: flex;
    align-items: center;
    gap: 8px;
  }
  .section h3::before {
    content: '';
    width: 3px;
    height: 14px;
    background: var(--race-red);
    flex-shrink: 0;
  }

  .control-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 10px;
    padding: 4px 0;
  }
  .control-row label {
    font-size: 0.78rem;
    color: var(--text-dim);
    font-weight: 500;
    letter-spacing: 0.5px;
  }
  .control-row .value {
    font-family: 'Share Tech Mono', monospace;
    font-size: 0.78rem;
    color: var(--amber);
    min-width: 55px;
    text-align: right;
    letter-spacing: 1px;
  }

  /* Custom range slider */
  input[type="range"] {
    -webkit-appearance: none;
    appearance: none;
    width: 130px;
    height: 4px;
    background: var(--bg-card);
    border: 1px solid var(--border);
    outline: none;
    cursor: pointer;
  }
  input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 14px;
    height: 14px;
    background: var(--race-red);
    border: 2px solid #fff;
    cursor: pointer;
    box-shadow: 0 0 6px rgba(220,38,38,0.5);
    transition: box-shadow 0.2s;
  }
  input[type="range"]::-webkit-slider-thumb:hover {
    box-shadow: 0 0 12px rgba(220,38,38,0.8);
  }
  input[type="range"]::-moz-range-thumb {
    width: 14px;
    height: 14px;
    background: var(--race-red);
    border: 2px solid #fff;
    border-radius: 0;
    cursor: pointer;
  }

  input[type="number"] {
    width: 68px;
    background: var(--bg-card);
    border: 1px solid var(--border);
    color: var(--amber);
    padding: 4px 8px;
    font-family: 'Share Tech Mono', monospace;
    font-size: 0.78rem;
    text-align: center;
    outline: none;
    transition: border-color 0.2s;
  }
  input[type="number"]:focus { border-color: var(--race-red); }

  select {
    background: var(--bg-card);
    border: 1px solid var(--border);
    color: var(--text);
    padding: 5px 10px;
    font-family: 'Rajdhani', sans-serif;
    font-size: 0.8rem;
    font-weight: 600;
    outline: none;
    cursor: pointer;
  }
  select:focus { border-color: var(--race-red); }

  /* Buttons */
  .btn {
    padding: 7px 16px;
    border: none;
    cursor: pointer;
    font-family: 'Rajdhani', sans-serif;
    font-size: 0.8rem;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 1.5px;
    transition: all 0.2s;
    position: relative;
    overflow: hidden;
  }
  .btn::before {
    content: '';
    position: absolute;
    top: 0; left: -100%;
    width: 100%; height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
    transition: left 0.4s;
  }
  .btn:hover::before { left: 100%; }

  .btn-primary {
    background: var(--race-red);
    color: #fff;
    border: 1px solid rgba(255,255,255,0.1);
  }
  .btn-primary:hover {
    background: #ef4444;
    box-shadow: 0 0 20px rgba(220,38,38,0.4);
  }
  .btn-secondary {
    background: var(--bg-card);
    color: var(--text-dim);
    border: 1px solid var(--border);
  }
  .btn-secondary:hover {
    background: var(--bg-card-hover);
    color: var(--text);
    border-color: var(--race-red);
  }
  .btn-sm { padding: 4px 10px; font-size: 0.7rem; }

  /* Weight items */
  .weight-item {
    background: var(--bg-card);
    border: 1px solid var(--border);
    border-left: 3px solid var(--amber);
    padding: 10px 12px;
    margin-bottom: 6px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    transition: all 0.2s;
    animation: fadeInStagger 0.3s ease-out both;
  }
  .weight-item:hover {
    background: var(--bg-card-hover);
    border-left-color: var(--race-red);
  }
  .weight-item .info { display: flex; flex-direction: column; }
  .weight-item .name {
    font-size: 0.82rem;
    font-weight: 700;
    letter-spacing: 0.5px;
  }
  .weight-item .detail {
    font-family: 'Share Tech Mono', monospace;
    font-size: 0.68rem;
    color: var(--text-dim);
    letter-spacing: 0.5px;
  }
  .weight-item .actions { display: flex; gap: 4px; }

  /* Rules */
  .rule-item {
    display: flex;
    align-items: flex-start;
    gap: 10px;
    padding: 8px 0;
    border-bottom: 1px solid var(--border);
    animation: fadeInStagger 0.3s ease-out both;
  }
  .rule-icon {
    font-size: 0.8rem;
    min-width: 22px;
    height: 22px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 700;
    border: 1px solid;
  }
  .rule-pass .rule-icon {
    color: var(--green);
    border-color: var(--green-dim);
    background: rgba(34,197,94,0.1);
  }
  .rule-fail .rule-icon {
    color: var(--race-red);
    border-color: var(--race-red-dim);
    background: rgba(220,38,38,0.1);
    animation: pulse 1.5s ease-in-out infinite;
  }
  .rule-text {
    font-size: 0.78rem;
    line-height: 1.5;
    color: var(--text-dim);
    font-weight: 500;
  }

  /* Axle cards */
  .axle-wheel {
    background: var(--bg-card);
    border: 1px solid var(--border);
    padding: 12px;
    margin-bottom: 8px;
    position: relative;
    overflow: hidden;
  }
  .axle-wheel::before {
    content: '';
    position: absolute;
    top: 0; left: 0;
    width: 3px;
    height: 100%;
    background: var(--blue);
  }
  .axle-wheel h4 {
    font-family: 'Rajdhani', sans-serif;
    font-size: 0.82rem;
    font-weight: 700;
    margin-bottom: 8px;
    display: flex;
    align-items: center;
    gap: 8px;
    text-transform: uppercase;
    letter-spacing: 1px;
  }
  .axle-wheel h4 .dot {
    width: 8px;
    height: 8px;
    box-shadow: 0 0 6px currentColor;
  }

  .checkbox-row {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 4px;
  }
  .checkbox-row input[type="checkbox"] {
    accent-color: var(--race-red);
    width: 14px;
    height: 14px;
  }
  .checkbox-row label {
    font-size: 0.76rem;
    color: var(--text-dim);
    font-weight: 500;
  }

  .preset-btns { display: flex; gap: 6px; margin-bottom: 14px; flex-wrap: wrap; }

  /* Print cards */
  .print-card {
    background: var(--bg-card);
    border: 1px solid var(--border);
    padding: 14px;
    margin-bottom: 10px;
    position: relative;
    transition: all 0.3s;
  }
  .print-card::before {
    content: '';
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 2px;
    background: linear-gradient(90deg, var(--race-red), transparent);
  }
  .print-card:hover {
    border-color: var(--border-light);
    transform: translateX(2px);
  }
  .print-card h4 {
    font-family: 'Rajdhani', sans-serif;
    font-size: 0.88rem;
    font-weight: 700;
    margin-bottom: 6px;
    letter-spacing: 0.5px;
  }
  .print-card p {
    font-size: 0.75rem;
    color: var(--text-dim);
    line-height: 1.5;
    margin-bottom: 10px;
  }

  .dim-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 4px;
    margin-top: 6px;
    padding-top: 8px;
    border-top: 1px solid var(--border);
  }
  .dim-grid .dim {
    font-family: 'Share Tech Mono', monospace;
    font-size: 0.68rem;
    color: var(--text-dim);
    letter-spacing: 0.5px;
  }
  .dim-grid .dim span { color: var(--amber); }

  .add-weight-form {
    background: var(--bg-card);
    border: 1px solid var(--race-red);
    padding: 14px;
    margin-bottom: 12px;
    display: none;
    animation: slideIn 0.2s ease-out;
  }
  .add-weight-form.show { display: block; }
  .form-row { margin-bottom: 8px; }
  .form-row label {
    display: block;
    font-size: 0.72rem;
    color: var(--text-dim);
    margin-bottom: 3px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 1px;
  }
  .form-row input[type="text"] {
    width: 100%;
    background: var(--bg-deep);
    border: 1px solid var(--border);
    color: var(--text);
    padding: 6px 10px;
    font-family: 'Rajdhani', sans-serif;
    font-size: 0.82rem;
    font-weight: 600;
    outline: none;
  }
  .form-row input[type="text"]:focus { border-color: var(--race-red); }
  .form-row input, .form-row select { width: 100%; }
  .form-actions { display: flex; gap: 6px; margin-top: 10px; }

  /* Scrollbar */
  #panel::-webkit-scrollbar { width: 4px; }
  #panel::-webkit-scrollbar-track { background: var(--bg-panel); }
  #panel::-webkit-scrollbar-thumb { background: var(--border-light); }
  #panel::-webkit-scrollbar-thumb:hover { background: var(--race-red); }

  /* Speed lines decorative */
  .speed-lines {
    position: absolute;
    right: -5px;
    top: 50%;
    transform: translateY(-50%);
    display: flex;
    flex-direction: column;
    gap: 3px;
    opacity: 0.15;
    z-index: 0;
  }
  .speed-lines div {
    height: 1px;
    background: var(--race-red);
  }

  /* Alignment notes style */
  .alignment-note {
    font-size: 0.75rem;
    color: var(--text-dim);
    line-height: 1.6;
    padding: 10px;
    background: var(--bg-card);
    border: 1px solid var(--border);
    border-left: 3px solid var(--amber);
  }
  .alignment-note strong {
    color: var(--amber);
    font-weight: 700;
    text-transform: uppercase;
    font-size: 0.7rem;
    letter-spacing: 1px;
  }

  /* ======== DESIGNS MODAL ======== */
  .designs-backdrop {
    position: fixed;
    inset: 0;
    z-index: 1000;
    background: rgba(0,0,0,0.6);
    backdrop-filter: blur(6px);
    display: flex;
    align-items: center;
    justify-content: center;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.2s ease;
  }
  .designs-backdrop.open {
    opacity: 1;
    pointer-events: auto;
  }
  .designs-modal {
    background: var(--bg-panel);
    border: 1px solid var(--border);
    border-top: 3px solid var(--race-red);
    border-radius: 8px;
    width: 480px;
    max-width: 95vw;
    max-height: 80vh;
    display: flex;
    flex-direction: column;
    box-shadow: 0 20px 60px rgba(0,0,0,0.5);
    transform: translateY(10px);
    transition: transform 0.2s ease;
  }
  .designs-backdrop.open .designs-modal {
    transform: translateY(0);
  }
  .designs-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 16px 20px;
    border-bottom: 1px solid var(--border);
  }
  .designs-header h2 {
    font-family: 'Bebas Neue', sans-serif;
    font-size: 1.3rem;
    letter-spacing: 2px;
    color: var(--text);
    font-weight: 400;
  }
  .designs-close {
    background: none;
    border: 1px solid var(--border);
    color: var(--text-dim);
    cursor: pointer;
    font-size: 1.1rem;
    padding: 4px 10px;
    border-radius: 4px;
    transition: all 0.15s;
  }
  .designs-close:hover { color: var(--text); border-color: var(--border-light); }
  .designs-name-row {
    display: flex;
    gap: 6px;
    padding: 8px 16px;
    border-bottom: 1px solid var(--border);
    align-items: center;
  }
  .designs-name-row input {
    flex: 1;
    background: var(--bg-deep);
    border: 1px solid var(--border);
    color: var(--text);
    font-family: 'Share Tech Mono', monospace;
    font-size: 0.85rem;
    padding: 6px 10px;
    border-radius: 4px;
    outline: none;
    transition: border-color 0.15s;
  }
  .designs-name-row input:focus {
    border-color: var(--race-red-dim);
  }
  .designs-name-row button {
    background: var(--bg-card);
    border: 1px solid var(--border);
    color: var(--text-dim);
    cursor: pointer;
    font-family: 'Rajdhani', sans-serif;
    font-weight: 600;
    font-size: 0.8rem;
    padding: 5px 12px;
    border-radius: 4px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    transition: all 0.15s;
  }
  .designs-name-row button:hover {
    color: var(--text);
    border-color: var(--border-light);
    background: var(--bg-card-hover);
  }
  .designs-list {
    flex: 1;
    overflow-y: auto;
    padding: 8px 12px;
    min-height: 80px;
  }
  .design-item {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 10px 14px;
    margin: 4px 0;
    background: var(--bg-card);
    border: 1px solid var(--border);
    border-left: 3px solid transparent;
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.15s;
  }
  .design-item:hover { background: var(--bg-card-hover); border-color: var(--border-light); }
  .design-item.active { border-left-color: var(--green); }
  .design-item-info { flex: 1; min-width: 0; }
  .design-item-name {
    font-weight: 600;
    font-size: 0.95rem;
    color: var(--text);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .design-item-meta {
    font-size: 0.75rem;
    color: var(--text-dim);
    font-family: 'Share Tech Mono', monospace;
    margin-top: 2px;
  }
  .design-item-delete {
    background: none;
    border: 1px solid transparent;
    color: var(--text-muted);
    cursor: pointer;
    font-size: 0.8rem;
    padding: 4px 8px;
    border-radius: 4px;
    margin-left: 8px;
    transition: all 0.15s;
    flex-shrink: 0;
  }
  .design-item-delete:hover { color: var(--race-red); border-color: var(--race-red-dim); }
  .designs-empty {
    text-align: center;
    padding: 30px 20px;
    color: var(--text-muted);
    font-size: 0.9rem;
  }
  .designs-empty span { display: block; font-size: 1.5rem; margin-bottom: 8px; }
  .designs-footer {
    display: flex;
    gap: 8px;
    padding: 14px 20px;
    border-top: 1px solid var(--border);
    flex-wrap: wrap;
  }
  .designs-footer button {
    flex: 1;
    min-width: 80px;
    padding: 8px 12px;
    background: var(--bg-card);
    border: 1px solid var(--border);
    color: var(--text-dim);
    font-family: 'Rajdhani', sans-serif;
    font-weight: 600;
    font-size: 0.85rem;
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.15s;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }
  .designs-footer button:hover { color: var(--text); border-color: var(--border-light); background: var(--bg-card-hover); }
  .save-flash {
    transition: color 0.3s, border-color 0.3s;
  }
  .save-flash.saved {
    color: var(--green) !important;
    border-color: var(--green) !important;
  }

  /* Rules footer link */
  .rules-footer {
    padding: 8px 16px;
    border-top: 1px solid var(--border);
    text-align: center;
    position: sticky;
    bottom: 0;
    background: var(--bg-deep);
    z-index: 10;
  }
  .rules-footer button {
    background: none;
    border: none;
    color: var(--text-muted);
    font-family: 'Share Tech Mono', monospace;
    font-size: 0.68rem;
    letter-spacing: 1.5px;
    text-transform: uppercase;
    cursor: pointer;
    padding: 4px 12px;
    transition: color 0.2s;
  }
  .rules-footer button:hover { color: var(--text-dim); }
  .rules-footer .rules-status {
    display: inline-block;
    width: 6px;
    height: 6px;
    border-radius: 50%;
    margin-right: 6px;
    vertical-align: middle;
  }
  .rules-footer .rules-status.pass { background: var(--green); box-shadow: 0 0 4px var(--green); }
  .rules-footer .rules-status.fail { background: var(--race-red); box-shadow: 0 0 4px var(--race-red); }

  /* ======== RESPONSIVE ======== */

  /* Tablet breakpoint */
  @media (max-width: 900px) {
    body { overflow: auto; height: auto; }
    #app {
      grid-template-columns: 1fr;
      grid-template-rows: auto 50vh 1fr;
      height: auto;
      min-height: 100vh;
    }
    #panel { border-left: none; border-top: 1px solid var(--border); }
    input[type="range"] { width: 200px; }
  }

  /* Mobile breakpoint */
  @media (max-width: 600px) {
    body { overflow: auto; height: auto; }
    #app {
      grid-template-columns: 1fr;
      grid-template-rows: auto 44vh 1fr;
      height: auto;
      min-height: 100vh;
    }

    /* Header — compact single-line layout */
    header {
      height: auto;
      min-height: 40px;
      padding: 6px 12px;
      flex-wrap: wrap;
      gap: 4px;
    }
    .header-left { gap: 8px; }
    .header-flag { width: 20px; height: 20px; }
    header h1 { font-size: 1.1rem; letter-spacing: 2px; }
    header h1 .dim { display: inline; font-size: 0.5rem; letter-spacing: 1px; margin-top: 0; margin-left: 4px; }
    .speed-lines { display: none; }
    .header-telemetry { width: 100%; flex-wrap: nowrap; gap: 0; align-items: center; }
    .weight-gauge { flex: 1; gap: 6px; min-width: 0; }
    .weight-gauge-bar { display: none; }
    .header-cog { flex: 1; padding-left: 10px; border-left: 1px solid var(--border); border-top: none; padding-top: 0; width: auto; min-width: 0; }
    .header-cog-label { font-size: 0.5rem; letter-spacing: 1px; }
    .header-cog-value { font-size: 0.85rem; overflow: hidden; text-overflow: ellipsis; }
    .weight-gauge-label { font-size: 0.5rem; letter-spacing: 1px; }
    .weight-gauge-value { font-size: 1rem; min-width: auto; }

    /* Viewport HUD — tighter positioning */
    .viewport-presets { top: 8px; left: 8px; gap: 4px; }
    .viewport-presets .preset-reset { padding: 5px 8px; font-size: 0.62rem; letter-spacing: 1px; }
    .viewport-presets .preset-group button { padding: 5px 8px; font-size: 0.62rem; letter-spacing: 1px; }
    .viewport-tools { top: 8px; right: 8px; gap: 4px; }
    .viewport-tools button { padding: 5px 10px; font-size: 0.62rem; letter-spacing: 1px; }
    .viewport-designs-btn { bottom: 6px; right: 6px; padding: 5px 10px; font-size: 0.62rem; letter-spacing: 1px; }
    .viewport-model-label { bottom: 6px; left: 8px; }
    .viewport-model-label .model-name { font-size: 0.85rem; letter-spacing: 2px; }
    .hud-bracket { width: 14px; height: 14px; }
    .hud-bracket.tl { top: 6px; left: 6px; }
    .hud-bracket.tr { top: 6px; right: 6px; }
    .hud-bracket.bl { bottom: 6px; left: 6px; }
    .hud-bracket.br { bottom: 6px; right: 6px; }

    /* Tabs — slightly smaller */
    .tabs button {
      padding: 12px 2px 10px;
      font-size: 0.62rem;
      letter-spacing: 1px;
    }

    /* Panel content */
    #panel { border-left: none; border-top: 1px solid var(--border); }
    .tab-content { padding: 12px; }

    /* Sliders — wider and more touch-friendly */
    input[type="range"] {
      width: 100%;
      height: 6px;
      flex: 1;
      margin: 0 10px;
    }
    input[type="range"]::-webkit-slider-thumb {
      width: 22px;
      height: 22px;
    }
    input[type="range"]::-moz-range-thumb {
      width: 22px;
      height: 22px;
    }

    /* Control rows — label above, slider full width */
    .control-row {
      flex-wrap: wrap;
      gap: 4px;
    }
    .control-row label {
      flex: 0 0 auto;
      font-size: 0.75rem;
    }
    .control-row .value {
      min-width: 50px;
      font-size: 0.75rem;
    }

    /* Form inputs — touch-friendly */
    input[type="number"] {
      font-size: 0.85rem;
      padding: 8px 10px;
      width: 80px;
    }
    select {
      font-size: 0.85rem;
      padding: 8px 10px;
    }
    .checkbox-row input[type="checkbox"] {
      width: 20px;
      height: 20px;
    }
    .checkbox-row label { font-size: 0.8rem; }

    /* Buttons — larger tap targets */
    .btn { padding: 10px 16px; font-size: 0.82rem; }
    .btn-sm { padding: 8px 12px; font-size: 0.72rem; }
    .preset-btns { gap: 4px; }
    .preset-btns .btn { padding: 8px 10px; font-size: 0.7rem; }

    /* Weight items — touch-friendly */
    .weight-item { padding: 12px; }
    .weight-item .actions { gap: 6px; }
    .weight-item .actions .btn-sm {
      padding: 8px 12px;
      min-width: 36px;
    }

    /* Axle cards */
    .axle-wheel { padding: 12px 12px 12px 14px; }

    /* Designs modal — full-width on mobile */
    .designs-modal {
      width: 100%;
      max-width: 100vw;
      max-height: 90vh;
      border-radius: 8px 8px 0 0;
      margin-top: auto;
    }
    .designs-backdrop {
      align-items: flex-end;
    }
    .designs-backdrop.open .designs-modal {
      transform: translateY(0);
    }
    .designs-modal {
      transform: translateY(100%);
    }
    .designs-header { padding: 14px 16px; }
    .designs-header h2 { font-size: 1.1rem; }
    .designs-list { padding: 6px 10px; }
    .design-item { padding: 12px; }
    .design-item-delete {
      padding: 8px 12px;
      font-size: 0.85rem;
    }
    .designs-footer {
      padding: 12px 16px 20px;
      gap: 6px;
    }
    .designs-footer button {
      padding: 12px 10px;
      font-size: 0.8rem;
      min-width: 70px;
    }

    /* Print cards */
    .print-card { padding: 12px; }
    .print-card:hover { transform: none; }

    /* Alignment notes */
    .alignment-note { font-size: 0.78rem; padding: 12px; }
  }

  /* Very small screens */
  @media (max-width: 380px) {
    header h1 { font-size: 0.95rem; }
    header h1 .dim { font-size: 0.45rem; }
    .weight-gauge-value { font-size: 0.9rem; }
    .header-cog-value { font-size: 0.75rem; }
    .viewport-presets .preset-reset { padding: 4px 6px; font-size: 0.58rem; }
    .viewport-presets .preset-group button { padding: 4px 6px; font-size: 0.58rem; }
    .viewport-tools button { padding: 4px 8px; font-size: 0.58rem; }
    .viewport-designs-btn { padding: 4px 8px; font-size: 0.58rem; }
    .tabs button { font-size: 0.58rem; letter-spacing: 0.5px; }
  }
</style>
</head>
<body>
<div id="app">
  <header>
    <div class="header-left">
      <div class="header-flag"><div></div><div></div><div></div><div></div></div>
      <h1>
        PINEWOOD <span class="red">DERBY</span>
        <span class="dim">// Race Engineering Lab</span>
      </h1>
    </div>
    <div class="speed-lines">
      <div style="width:60px"></div>
      <div style="width:45px"></div>
      <div style="width:75px"></div>
      <div style="width:30px"></div>
      <div style="width:55px"></div>
    </div>
    <div class="header-telemetry">
      <div class="weight-gauge">
        <div>
          <div class="weight-gauge-label">Mass</div>
          <div class="weight-gauge-value" id="weight-text">0.00<span style="font-size:0.9rem;color:var(--text-dim)"> / 5.00 oz</span></div>
        </div>
        <div class="weight-gauge-bar">
          <div class="weight-gauge-fill" id="weight-fill" style="width:0%;background:var(--green)"></div>
        </div>
        <div class="status-light" id="status-light"></div>
      </div>
      <div class="header-cog">
        <div>
          <div class="header-cog-label">Center of Gravity</div>
          <div class="header-cog-value" id="header-cog-text">—</div>
        </div>
        <div class="status-light" id="cog-status-light"></div>
      </div>
    </div>
  </header>

  <div id="viewport">
    <canvas id="three-canvas"></canvas>
    <div class="scan-overlay"></div>
    <div class="hud-bracket tl"></div>
    <div class="hud-bracket tr"></div>
    <div class="hud-bracket bl"></div>
    <div class="hud-bracket br"></div>
    <div class="viewport-model-label" onclick="openDesignsModal()" style="cursor:pointer">
      <div class="model-name" id="config-name-display">BSA BLOCK</div>
    </div>
    <button class="viewport-designs-btn" onclick="openDesignsModal()">Load / Save Designs</button>
    <!-- Top-left: View presets -->
    <div class="viewport-presets">
      <button onclick="resetCamera()" class="preset-reset">Reset</button>
      <div class="preset-group">
        <button onclick="setView('top')" id="preset-top">Top</button>
        <button onclick="setView('side')" id="preset-side">Side</button>
        <button onclick="setView('front')" id="preset-front">Front</button>
      </div>
    </div>

    <!-- Top-right: Tools (below model label) -->
    <div class="viewport-tools">
      <button onclick="toggleRotate()" id="rotate-btn" class="spin-toggle">○ Auto-Spin</button>
      <button id="view-mode-btn" onclick="cycleViewMode()">X-Ray ▸</button>
    </div>

    <input type="file" id="file-input" accept=".json" style="display:none" onchange="importDesignFromFile(this)">
  </div>

  <!-- Designs Modal -->
  <div class="designs-backdrop" id="designs-backdrop" onclick="if(event.target===this)closeDesignsModal()">
    <div class="designs-modal">
      <div class="designs-header">
        <h2>SAVED DESIGNS</h2>
        <button class="designs-close" onclick="closeDesignsModal()">&times;</button>
      </div>
      <div class="designs-name-row">
        <input type="text" id="design-name-input" placeholder="Design name&hellip;" spellcheck="false">
        <button id="save-btn" class="save-flash" onclick="saveDesign()">Save</button>
      </div>
      <div class="designs-list" id="designs-list"></div>
      <div class="designs-footer">
        <button onclick="newDesign()">New</button>
        <button onclick="document.getElementById('file-input').click()">Import</button>
        <button onclick="exportCurrentDesign()">Export</button>
      </div>
    </div>
  </div>

  <div id="panel">
    <div class="tabs">
      <button class="active" onclick="switchTab('body', this)">Body</button>
      <button onclick="switchTab('weights', this)">Weights</button>
      <button onclick="switchTab('axles', this)">Axles</button>
    </div>

    <!-- BODY TAB -->
    <div class="tab-content active" id="tab-body">
      <div class="section">
        <h3>Body Dimensions</h3>
        <div class="control-row">
          <label>Nose Height</label>
          <input type="range" min="0.05" max="1.25" step="0.05" value="1.25" oninput="updateBody('noseHeight', this.value)">
          <span class="value" id="val-noseHeight">1.25"</span>
        </div>
        <div class="control-row">
          <label>Front Height</label>
          <input type="range" min="0.2" max="1.25" step="0.05" value="1.25" oninput="updateBody('frontHeight', this.value)">
          <span class="value" id="val-frontHeight">1.25"</span>
        </div>
        <div class="control-row">
          <label>Scoop Depth</label>
          <input type="range" min="0" max="0.75" step="0.05" value="0" oninput="updateBody('scoopDepth', this.value)">
          <span class="value" id="val-scoopDepth">0.00"</span>
        </div>
        <div class="control-row">
          <label>Rear Height</label>
          <input type="range" min="0.25" max="1.25" step="0.05" value="1.25" oninput="updateBody('rearHeight', this.value)">
          <span class="value" id="val-rearHeight">1.25"</span>
        </div>
        <div class="control-row">
          <label>Tail Height</label>
          <input type="range" min="0" max="1.25" step="0.05" value="1.25" oninput="updateBody('tailHeight', this.value)">
          <span class="value" id="val-tailHeight">1.25"</span>
        </div>
      </div>
      <div class="section">
        <h3>Wood Estimate</h3>
        <div class="control-row">
          <label>Raw block weight</label>
          <input type="number" value="3.42" step="0.01" min="0" max="5" id="raw-wood-weight" oninput="updateWoodWeight()">
          <span class="value">oz</span>
        </div>
        <div class="control-row">
          <label>Est. after cuts</label>
          <span class="value" id="val-cut-weight" style="color:var(--green)">—</span>
        </div>
        <div class="control-row">
          <label>Material removed</label>
          <span class="value" id="val-removed" style="color:var(--race-red)">—</span>
        </div>
      </div>
      <div class="section">
        <h3>Quick Dimensions</h3>
        <div class="dim-grid">
          <div class="dim">Length: <span id="dim-l">7.00"</span></div>
          <div class="dim">Width: <span id="dim-w">2.50"</span></div>
          <div class="dim">Max Height: <span id="dim-h">0.45"</span></div>
          <div class="dim">Clearance: <span id="dim-c">~0.44"</span></div>
        </div>
      </div>
    </div>

    <!-- WEIGHTS TAB -->
    <div class="tab-content" id="tab-weights">
      <div class="section">
        <h3>Weight Budget</h3>
        <div class="control-row">
          <label>Wood (after cuts)</label>
          <span class="value" id="wt-wood">—</span>
        </div>
        <div class="control-row">
          <label>Added weights</label>
          <span class="value" id="wt-added">0.00 oz</span>
        </div>
        <div class="control-row" id="wt-displaced-row" style="display:none;">
          <label style="font-size:0.72rem;color:var(--text-muted);">&nbsp;&nbsp;(displaces wood)</label>
          <span class="value" id="wt-displaced" style="font-size:0.72rem;color:var(--text-muted);">0.00 oz</span>
        </div>
        <div class="control-row">
          <label>Wheels + Axles</label>
          <input type="number" id="wheel-axle-weight" value="0.49" step="0.01" min="0" max="3" oninput="updateWheelAxleWeight()">
          <span class="value">oz</span>
        </div>
        <div class="control-row">
          <label>Other (paint, glue, etc.)</label>
          <input type="number" id="misc-weight" value="0" step="0.01" min="0" max="3" oninput="updateMiscWeight()">
          <span class="value">oz</span>
        </div>
        <div class="control-row" id="misc-weight-x-row" style="display:none;">
          <label>Other weight center X <span id="misc-weight-x-val" style="color:var(--amber);font-family:'Share Tech Mono',monospace;float:right">3.5"</span></label>
          <input type="range" id="misc-weight-x" min="0" max="7" step="0.1" value="3.5" oninput="updateMiscWeightX(this.value)">
        </div>
        <div class="control-row" style="border-top:1px solid var(--border); padding-top:8px;">
          <label style="color:var(--text); font-weight:700; text-transform:uppercase; letter-spacing:1px;">Total</label>
          <span class="value" id="wt-total" style="font-weight:700;">—</span>
        </div>
        <div class="control-row">
          <label>Remaining to 5.00 oz</label>
          <span class="value" id="wt-remaining" style="color:var(--amber)">—</span>
        </div>
      </div>
      <div class="section" id="planner-section">
        <h3>Weight Planner</h3>
        <div id="planner-budget" style="font-family:'Share Tech Mono',monospace;font-size:0.78rem;color:var(--text-dim);margin-bottom:8px;"></div>
        <div id="planner-items"></div>
        <div style="display:flex;gap:6px;margin:8px 0;">
          <select id="planner-add-cat" style="flex:1;" onchange="updatePlannerProductOptions()"></select>
          <select id="planner-add-product" style="flex:1;"></select>
          <button class="btn btn-secondary btn-sm" onclick="addPlannerItem()">+ Add</button>
        </div>
        <div id="planner-total" style="font-family:'Share Tech Mono',monospace;font-size:0.78rem;margin-bottom:8px;"></div>
        <div id="planner-warning" style="font-size:0.72rem;margin-bottom:8px;"></div>
        <div style="display:flex;gap:6px;flex-wrap:wrap;">
          <button class="btn btn-primary btn-sm" onclick="runOptimizer()" style="flex:1;">Optimize Placement</button>
          <button class="btn btn-secondary btn-sm" onclick="applyPlacements()" id="planner-apply-btn" style="flex:1;display:none;">Apply All</button>
        </div>
        <div id="planner-results" style="font-family:'Share Tech Mono',monospace;font-size:0.72rem;margin-top:8px;"></div>
        <div style="margin-top:8px;">
          <button class="btn btn-secondary btn-sm" onclick="quickFillRemaining()" style="width:100%;">Quick Fill Remaining</button>
        </div>
        <div id="auto-weight-result" style="margin-top:8px;"></div>
        <button class="btn btn-primary" onclick="applyAutoWeight()" id="auto-weight-btn" style="width:100%;margin-top:6px;display:none;">Calculate Optimal Weight</button>
      </div>
      <div class="section">
        <h3>Components</h3>
        <button class="btn btn-primary" onclick="toggleAddForm()" id="add-weight-btn">+ Add Weight</button>
        <div class="add-weight-form" id="add-form">
          <div class="form-row">
            <label>Name</label>
            <input type="text" id="wf-name" placeholder="e.g. Rear tungsten cube">
          </div>
          <div class="form-row">
            <label>Category</label>
            <select id="wf-category" onchange="updateCatalogProducts()"></select>
          </div>
          <div class="form-row">
            <label>Product</label>
            <select id="wf-product" onchange="selectCatalogProduct()"></select>
          </div>
          <div class="form-row" id="wf-qty-row" style="display:none;">
            <label>Quantity</label>
            <input type="number" id="wf-qty" value="1" min="1" max="50" step="1" oninput="updateQtyWeight();previewWeight()">
          </div>
          <div class="form-row" id="wf-weight-row">
            <label>Weight (oz) <span id="wf-weight-note" style="font-size:0.7rem;color:var(--text-dim);"></span></label>
            <input type="number" id="wf-weight" step="0.01" min="0" max="5" value="0.25" oninput="previewWeight()">
          </div>
          <div id="wf-dims-display" style="font-size:0.72rem;color:var(--text-dim);font-family:'Share Tech Mono',monospace;padding:2px 0 6px;"></div>
          <div class="form-row">
            <label>Position X (inches from front) <span id="wf-x-val" style="color:var(--amber);font-family:'Share Tech Mono',monospace;float:right">5.5"</span></label>
            <input type="range" id="wf-x" min="0" max="7" step="0.1" value="5.5" oninput="document.getElementById('wf-x-val').textContent=parseFloat(this.value).toFixed(1)+'&quot;';previewWeight();checkBodyFit()">
          </div>
          <div class="form-row">
            <label>Position Y (left-right offset) <span id="wf-y-val" style="color:var(--amber);font-family:'Share Tech Mono',monospace;float:right">0.0"</span></label>
            <input type="range" id="wf-y" min="-1.2" max="1.2" step="0.1" value="0" oninput="document.getElementById('wf-y-val').textContent=parseFloat(this.value).toFixed(1)+'&quot;';previewWeight()">
          </div>
          <div class="checkbox-row" style="margin-top:8px;margin-bottom:4px;">
            <input type="checkbox" id="wf-embedded" onchange="previewWeight();updateNetWeightDisplay();checkBodyFit()">
            <label for="wf-embedded">Embedded (drilled into body)</label>
          </div>
          <div id="wf-net-weight" style="font-size:0.72rem;color:var(--text-dim);font-family:'Share Tech Mono',monospace;padding:0 0 6px;"></div>
          <div id="wf-fit-warning" style="font-size:0.72rem;padding:0 0 6px;"></div>
          <div class="form-actions">
            <button class="btn btn-primary btn-sm" id="wf-confirm-btn" onclick="addWeight()">Confirm</button>
            <button class="btn btn-secondary btn-sm" onclick="toggleAddForm()">Cancel</button>
            <button class="btn btn-secondary btn-sm" onclick="autoOptimizeX()" style="margin-left:auto;">Auto X</button>
          </div>
        </div>
        <div id="weight-list"></div>
      </div>
    </div>

    <!-- AXLES TAB -->
    <div class="tab-content" id="tab-axles">
      <div class="section">
        <h3>Axle Mounting</h3>
        <div class="control-row">
          <label>Mount Type</label>
          <select id="axle-mount-type" onchange="updateAxleMountType(this.value)">
            <option value="slot">Kit Slots (bottom)</option>
            <option value="drilled">Drilled Holes (side)</option>
          </select>
        </div>
        <div id="drilled-options" style="display:none;">
          <div class="control-row">
            <label>Hole Height</label>
            <input type="range" id="drilled-height-slider" min="0.044" max="0.215" step="0.005" value="0.1" oninput="updateDrilledHeight(this.value)">
            <span class="value" id="val-drilled-height">0.100"</span>
          </div>
          <div class="control-row">
            <label>Ground Clearance</label>
            <span class="value" id="val-drilled-clearance" style="color:var(--green)">0.490"</span>
          </div>
          <div class="alignment-note" style="margin-top:8px;">
            <strong>Drilled holes:</strong> Lower hole = more clearance. Max height clamped to maintain &ge; &#x215C;" (0.375") clearance. Use a drill press or printed jig for straight holes.
          </div>
        </div>
        <div id="slot-info" style="margin-top:8px;">
          <div class="control-row">
            <label>Slot height (fixed)</label>
            <span class="value" id="val-slot-height">0.375"</span>
          </div>
        </div>
      </div>
      <div class="section">
        <h3>Presets</h3>
        <div class="preset-btns">
          <button class="btn btn-secondary btn-sm" onclick="applyAxlePreset('rail')">Rail Rider</button>
          <button class="btn btn-secondary btn-sm" onclick="applyAxlePreset('canted')">Canted</button>
          <button class="btn btn-secondary btn-sm" onclick="applyAxlePreset('stock')">Stock</button>
        </div>
      </div>
      <div class="section">
        <h3>Front Axle</h3>
        <div class="axle-wheel" style="--axle-color: var(--blue);">
          <h4><span class="dot" style="background:var(--blue);color:var(--blue)"></span> Front Left</h4>
          <div class="control-row"><label>Bend °</label><input type="range" min="0" max="4" step="0.25" value="1.5" oninput="updateAxle('fl','bend',this.value)"><span class="value" id="ax-fl-bend">1.5°</span></div>
          <div class="control-row"><label>Camber °</label><input type="range" min="-3" max="3" step="0.25" value="0" oninput="updateAxle('fl','camber',this.value)"><span class="value" id="ax-fl-camber">0.0°</span></div>
          <div class="checkbox-row"><input type="checkbox" id="ax-fl-raised" onchange="updateAxle('fl','raised',this.checked)"><label for="ax-fl-raised">Raised (non-contact)</label></div>
        </div>
        <div class="axle-wheel">
          <h4><span class="dot" style="background:var(--green);color:var(--green)"></span> Front Right</h4>
          <div class="control-row"><label>Bend °</label><input type="range" min="0" max="4" step="0.25" value="1.5" oninput="updateAxle('fr','bend',this.value)"><span class="value" id="ax-fr-bend">1.5°</span></div>
          <div class="control-row"><label>Camber °</label><input type="range" min="-3" max="3" step="0.25" value="0" oninput="updateAxle('fr','camber',this.value)"><span class="value" id="ax-fr-camber">0.0°</span></div>
          <div class="checkbox-row"><input type="checkbox" id="ax-fr-raised" onchange="updateAxle('fr','raised',this.checked)"><label for="ax-fr-raised">Raised (non-contact)</label></div>
        </div>
      </div>
      <div class="section">
        <h3>Rear Axle</h3>
        <div class="axle-wheel">
          <h4><span class="dot" style="background:var(--amber);color:var(--amber)"></span> Rear Left</h4>
          <div class="control-row"><label>Bend °</label><input type="range" min="0" max="4" step="0.25" value="1.5" oninput="updateAxle('rl','bend',this.value)"><span class="value" id="ax-rl-bend">1.5°</span></div>
          <div class="control-row"><label>Camber °</label><input type="range" min="-3" max="3" step="0.25" value="0" oninput="updateAxle('rl','camber',this.value)"><span class="value" id="ax-rl-camber">0.0°</span></div>
          <div class="checkbox-row"><input type="checkbox" id="ax-rl-raised" onchange="updateAxle('rl','raised',this.checked)"><label for="ax-rl-raised">Raised (non-contact)</label></div>
        </div>
        <div class="axle-wheel">
          <h4><span class="dot" style="background:var(--race-red);color:var(--race-red)"></span> Rear Right</h4>
          <div class="control-row"><label>Bend °</label><input type="range" min="0" max="4" step="0.25" value="1.5" oninput="updateAxle('rr','bend',this.value)"><span class="value" id="ax-rr-bend">1.5°</span></div>
          <div class="control-row"><label>Camber °</label><input type="range" min="-3" max="3" step="0.25" value="0" oninput="updateAxle('rr','camber',this.value)"><span class="value" id="ax-rr-camber">0.0°</span></div>
          <div class="checkbox-row"><input type="checkbox" id="ax-rr-raised" onchange="updateAxle('rr','raised',this.checked)"><label for="ax-rr-raised">Raised (non-contact)</label></div>
        </div>
      </div>
      <div class="section">
        <h3>Alignment Notes</h3>
        <div class="alignment-note">
          <strong>Rail Rider:</strong> One front wheel raised, car steers into guide rail using 3 contact wheels. Reduces friction. Standard competitive setup.<br><br>
          <strong>Bend Angle:</strong> Bending the axle head ~1.5° lifts the wheel slightly off straight, reducing hub friction and encouraging rail contact.<br><br>
          <strong>Camber:</strong> Tilts the wheel so only the inner edge contacts the track, reducing rolling friction.
        </div>
      </div>
    </div>

    <div class="rules-footer">
      <button onclick="openRulesModal()"><span class="rules-status pass" id="rules-status-dot"></span>Rules Compliance</button>
    </div>
  </div>

  <!-- Rules Modal -->
  <div class="designs-backdrop" id="rules-backdrop" onclick="if(event.target===this)closeRulesModal()">
    <div class="designs-modal">
      <div class="designs-header">
        <h2>RULES COMPLIANCE</h2>
        <button class="designs-close" onclick="closeRulesModal()">&times;</button>
      </div>
      <div class="designs-list" id="rules-list" style="padding:12px 16px;"></div>
    </div>
  </div>
</div>

<script>
// ╔══════════════════════════════════════════════════════════════════╗
// ║  CONFIGURATION — Edit these values to match your car & rules   ║
// ╚══════════════════════════════════════════════════════════════════╝
const CONFIG = {

  // --- Stock Block (uncut) ---
  stockLength:   7,      // inches — standard BSA block length
  stockWidth:    1.75,   // inches — standard BSA block width
  stockHeight:   1.25,   // inches — standard BSA block height (used for volume estimate)
  stockWeight:   3.42,   // oz — weigh your raw block before any cuts

  // --- Wheels & Axles ---
  wheelDiameter:       1.18,  // inches — BSA official wheel OD
  wheelWidth:          0.37,  // inches — BSA official wheel width
  wheelAxleWeight:     0.49,  // oz — weigh all 4 wheels + 4 axles together
  raisedWheelLift:     0.08,  // inches — extra lift when wheel is marked "raised"

  // --- Axle Mounting ---
  axleSlotHeight:      0.044, // inches — center of axle in kit slot (≈ flush with block bottom, half axle diameter)
  drilledAxleHeight:   0.1,   // inches — default drill height from bottom (lower = more clearance)
  drilledAxleHeightMin: 0.044, // inches — minimum (flush with bottom, same as slot)
  drilledAxleHeightMax: 0.215, // inches — maximum drill height (wheelDia/2 - 3/8" clearance)

  // --- Axle Slot Positions ---
  frontAxleFromFront:  1.75,  // inches — front axle slot measured from front of car
  rearAxleFromBack:    1.0,   // inches — rear axle slot measured from back of car

  // --- Competition Rules (Pack 3) ---
  maxWeight:           5.0,   // oz — maximum total car weight
  maxLength:           7.0,   // inches
  maxWidth:            2.75,  // inches
  minWidth:            1.75,  // inches — minimum width between wheels
  minClearance:        0.375, // inches — minimum bottom clearance (⅜")

  // --- Performance Targets ---
  cogTargetFromRearAxle: 1.0, // inches — ideal CoG position in front of rear axle
  cogToleranceGreen:     0.15,// inches — how close to target to show green

  // --- Weight Gauge ---
  warningThreshold:    0.2,   // oz below max — when gauge turns amber (e.g. 4.8 for 5.0 max)

  // --- Default Axle Settings ---
  defaultBend:   1.5,  // degrees
  defaultCamber: 0,    // degrees

  // --- Axle Presets ---
  presets: {
    rail:   { fl: { bend: 1.5, camber: 1.5, raised: true  }, fr: { bend: 1.5, camber: 1.5, raised: false }, rl: { bend: 1.5, camber: 1.5, raised: false }, rr: { bend: 1.5, camber: 1.5, raised: false } },
    canted: { fl: { bend: 2.0, camber: 2.0, raised: false }, fr: { bend: 2.0, camber: 2.0, raised: false }, rl: { bend: 2.0, camber: 2.0, raised: false }, rr: { bend: 2.0, camber: 2.0, raised: false } },
    stock:  { fl: { bend: 0,   camber: 0,   raised: false }, fr: { bend: 0,   camber: 0,   raised: false }, rl: { bend: 0,   camber: 0,   raised: false }, rr: { bend: 0,   camber: 0,   raised: false } },
  },

  // --- Material Densities (oz/in³) ---
  densityTungsten: 11.13,
  densityLead: 6.55,
  densitySteel: 4.51,
};
// ═══════════════════════ END CONFIGURATION ═══════════════════════

// ===== WEIGHT CATALOG =====
const WEIGHT_CATALOG = {
  // Tungsten Cubes
  'tc-25':  { name: '1/4" Tungsten Cube',  cat: 'cube',  density: 11.13, weight: 0.174, dims: {x:.25,y:.25,z:.25},     shape:'box',    embed:true  },
  'tc-38':  { name: '3/8" Tungsten Cube',  cat: 'cube',  density: 11.13, weight: 0.586, dims: {x:.375,y:.375,z:.375}, shape:'box',    embed:true  },
  // Tungsten Rods
  'tr-25-1':  { name: '1/4"×1" Rod',   cat: 'rod', density: 11.13, dims: {d:.25,l:1},   shape:'cyl', embed:true },
  'tr-25-2':  { name: '1/4"×2" Rod',   cat: 'rod', density: 11.13, dims: {d:.25,l:2},   shape:'cyl', embed:true },
  'tr-25-3':  { name: '1/4"×3" Rod',   cat: 'rod', density: 11.13, dims: {d:.25,l:3},   shape:'cyl', embed:true },
  'tr-38-1':  { name: '3/8"×1" Rod',   cat: 'rod', density: 11.13, dims: {d:.375,l:1},  shape:'cyl', embed:true },
  'tr-38-2':  { name: '3/8"×2" Rod',   cat: 'rod', density: 11.13, dims: {d:.375,l:2},  shape:'cyl', embed:true },
  'tr-38-3':  { name: '3/8"×3" Rod',   cat: 'rod', density: 11.13, dims: {d:.375,l:3},  shape:'cyl', embed:true },
  'tr-50-1':  { name: '1/2"×1" Rod',   cat: 'rod', density: 11.13, dims: {d:.5,l:1},    shape:'cyl', embed:true },
  'tr-50-2':  { name: '1/2"×2" Rod',   cat: 'rod', density: 11.13, dims: {d:.5,l:2},    shape:'cyl', embed:true },
  // Tungsten Putty
  'tp':     { name: 'Tungsten Putty',    cat: 'putty',  density: 11.0,  weight: null, shape:'putty', embed:false, userWeight:true },
  // Tungsten Plates
  'tw-plate':{ name: 'Flat Plate 1.5×0.5×1/8"', cat:'plate', density:11.13, weight:1.04, dims:{x:1.5,y:.125,z:.5}, shape:'box', embed:false },
  // Lead
  'ls':     { name: 'Lead Strip 3×1/2×1/16"', cat: 'lead',  density: 6.55, weight: 0.61, dims:{x:3,y:.0625,z:.5}, shape:'box', embed:false },
  'lw':     { name: 'Lead Wire (cut to wt)', cat: 'lead',  density: 6.55, weight: null, shape:'putty', embed:false, userWeight:true },
  // Steel BBs
  'sb':     { name: 'Steel BB',           cat: 'bb',     density: 4.51, weight: 0.021, dims:{d:.177}, shape:'sphere', embed:true },
  // Custom
  'custom': { name: 'Custom Weight',      cat: 'custom', density: 0, weight: null, shape:'box', embed:false, userWeight:true },
};

const CATALOG_CATEGORIES = [
  { key: 'cube',  label: 'Tungsten Cube' },
  { key: 'rod',   label: 'Tungsten Rod' },
  { key: 'putty', label: 'Tungsten Putty' },
  { key: 'plate', label: 'Tungsten Plate' },
  { key: 'lead',  label: 'Lead' },
  { key: 'bb',    label: 'Steel BBs' },
  { key: 'custom',label: 'Custom' },
];

function getCatalogWeight(id) {
  const item = WEIGHT_CATALOG[id];
  if (!item) return 0;
  if (item.weight != null) return item.weight;
  // Compute from cylinder geometry: π r² l × density
  if (item.shape === 'cyl' && item.dims) {
    const r = item.dims.d / 2;
    return Math.PI * r * r * item.dims.l * item.density;
  }
  return 0;
}

function getCatalogDimsText(id) {
  const item = WEIGHT_CATALOG[id];
  if (!item || !item.dims) return '';
  if (item.shape === 'box') return `${item.dims.x}" × ${item.dims.y}" × ${item.dims.z}"`;
  if (item.shape === 'cyl') return `${formatDiameter(item.dims.d)} dia × ${item.dims.l}"`;
  if (item.shape === 'sphere') return `${formatDiameter(item.dims.d)} dia`;
  return '';
}

// ===== STATE =====
const STATE_VERSION = 10; // bump to reset saved state when CONFIG changes
const DEFAULTS = {
  _v: STATE_VERSION,
  body: { length: CONFIG.stockLength, width: CONFIG.stockWidth, rearHeight: CONFIG.stockHeight, frontHeight: CONFIG.stockHeight, noseHeight: CONFIG.stockHeight, scoopDepth: 0, tailHeight: CONFIG.stockHeight },
  rawWoodWeight: CONFIG.stockWeight,
  weights: [],
  axles: {
    fl: { bend: CONFIG.defaultBend, camber: CONFIG.defaultCamber, raised: false },
    fr: { bend: CONFIG.defaultBend, camber: CONFIG.defaultCamber, raised: false },
    rl: { bend: CONFIG.defaultBend, camber: CONFIG.defaultCamber, raised: false },
    rr: { bend: CONFIG.defaultBend, camber: CONFIG.defaultCamber, raised: false },
  },
  axleMountType: 'slot',  // 'slot' = kit notches (bottom), 'drilled' = drilled holes (side)
  drilledAxleHeight: CONFIG.drilledAxleHeight,
  wheelAxleWeight: CONFIG.wheelAxleWeight,
  maxWeight: CONFIG.maxWeight,
  miscWeight: 0,
  miscWeightX: 3.5,
  plannerItems: [],
  configName: 'Untitled',
  nextId: 1,
  currentDesignId: null,
};

function migrateState(parsed) {
  if (parsed._v < 10) {
    if (parsed.miscWeight === undefined) parsed.miscWeight = 0;
    if (parsed.miscWeightX === undefined) parsed.miscWeightX = 3.5;
    if (parsed.plannerItems === undefined) parsed.plannerItems = [];
    parsed._v = 10;
  }
  return parsed;
}

function loadState() {
  try {
    const saved = localStorage.getItem('pinewood-derby-state');
    if (saved) {
      let parsed = JSON.parse(saved);
      if (parsed._v && parsed._v >= 9 && parsed._v < STATE_VERSION) {
        parsed = migrateState(parsed);
      } else if (parsed._v !== STATE_VERSION) {
        localStorage.removeItem('pinewood-derby-state');
        return { ...DEFAULTS, body: { ...DEFAULTS.body }, axles: { fl: { ...DEFAULTS.axles.fl }, fr: { ...DEFAULTS.axles.fr }, rl: { ...DEFAULTS.axles.rl }, rr: { ...DEFAULTS.axles.rr } }, weights: [], plannerItems: [] };
      }
      return { ...DEFAULTS, ...parsed, body: { ...DEFAULTS.body, ...(parsed.body || {}) }, axles: { ...DEFAULTS.axles, ...(parsed.axles || {}) } };
    }
  } catch (e) { /* ignore corrupt data */ }
  return { ...DEFAULTS, body: { ...DEFAULTS.body }, axles: { fl: { ...DEFAULTS.axles.fl }, fr: { ...DEFAULTS.axles.fr }, rl: { ...DEFAULTS.axles.rl }, rr: { ...DEFAULTS.axles.rr } }, weights: [], plannerItems: [] };
}

function saveState() {
  try {
    const toSave = Object.assign({}, state, { weights: state.weights.filter(w => w.id !== -999) });
    localStorage.setItem('pinewood-derby-state', JSON.stringify(toSave));
  } catch (e) { /* storage full or unavailable */ }
}

const state = loadState();

// ===== THREE.JS SETUP =====
const canvas = document.getElementById('three-canvas');
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x12141c);

// Fog for dramatic depth
scene.fog = new THREE.FogExp2(0x12141c, 0.025);

const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 100);
camera.position.set(6, 5, 8);
camera.lookAt(0, 0, 0);
const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.2;
renderer.localClippingEnabled = true;

// Dramatic lighting — boosted for contrast
const ambient = new THREE.AmbientLight(0x334466, 1.0);
scene.add(ambient);

// Hemisphere light for natural fill (sky blue above, warm below)
const hemiLight = new THREE.HemisphereLight(0x6688cc, 0x443322, 0.5);
scene.add(hemiLight);

// Key light — dramatic warm
const keyLight = new THREE.DirectionalLight(0xffeedd, 1.2);
keyLight.position.set(5, 8, 3);
keyLight.castShadow = true;
keyLight.shadow.mapSize.width = 2048;
keyLight.shadow.mapSize.height = 2048;
scene.add(keyLight);

// Fill light — cool blue, stronger
const fillLight = new THREE.DirectionalLight(0x6688cc, 0.6);
fillLight.position.set(-5, 3, -3);
scene.add(fillLight);

// Rim light — red accent from behind
const rimLight = new THREE.DirectionalLight(0xdc2626, 0.35);
rimLight.position.set(-3, 2, -6);
scene.add(rimLight);

// Low front kick light to catch wheel faces
const kickLight = new THREE.DirectionalLight(0x8899bb, 0.4);
kickLight.position.set(0, 1, 8);
scene.add(kickLight);

// Spotlight from above for dramatic pool of light
const spotLight = new THREE.SpotLight(0xffffff, 0.8, 30, Math.PI / 5, 0.4, 1);
spotLight.position.set(0, 12, 0);
spotLight.castShadow = true;
scene.add(spotLight);

// Ground — blueprint blue surface
const groundGeo = new THREE.PlaneGeometry(30, 30);
const groundMat = new THREE.MeshStandardMaterial({
  color: 0x0c1a2e,
  roughness: 0.5,
  metalness: 0.4
});
const ground = new THREE.Mesh(groundGeo, groundMat);
ground.rotation.x = -Math.PI / 2;
ground.position.y = -0.5;
ground.receiveShadow = true;
scene.add(ground);

// Blueprint grid lines
const gridHelper = new THREE.GridHelper(14, 28, 0x1a3a5c, 0x122a48);
gridHelper.position.y = -0.49;
scene.add(gridHelper);

// Track guide rail
const railGeo = new THREE.BoxGeometry(10, 0.2, 0.1);
const railMat = new THREE.MeshStandardMaterial({ color: 0x333340, metalness: 0.6, roughness: 0.4 });
const rail = new THREE.Mesh(railGeo, railMat);
rail.position.set(0, -0.45, 0);
scene.add(rail);

// Materials — upgraded
const woodMat = new THREE.MeshStandardMaterial({
  color: 0xc49a6c,
  roughness: 0.7,
  metalness: 0.05,
});
const wheelMat = new THREE.MeshStandardMaterial({
  color: 0x2a2a35,
  roughness: 0.35,
  metalness: 0.4
});
const axleMat = new THREE.MeshStandardMaterial({
  color: 0x999999,
  metalness: 0.9,
  roughness: 0.2
});
const weightColors = {
  tungsten: 0xb8860b, tungsten_cylinder: 0xb8860b,
  lead_strip: 0x888888, steel_bbs: 0x666680, custom: 0xdc2626,
  putty: 0xc4a035, plate: 0xb8860b, lead: 0x888888, bb: 0x666680
};
const cogMat = new THREE.MeshStandardMaterial({
  color: 0xff0000,
  emissive: 0xff0000,
  emissiveIntensity: 0.8
});

// Groups
const carGroup = new THREE.Group();
scene.add(carGroup);
const rulerGroup = new THREE.Group();
scene.add(rulerGroup);
let bodyMesh, cogMarker;
const wheelMeshes = {};
const axleMeshes = {};
const weightMeshes = [];
let xrayMode = false;
let cutawayMode = false;
const cutawayPlane = new THREE.Plane(new THREE.Vector3(0, 0, -1), 0);

// Derived from CONFIG (recalculated in buildCar when length changes)
let AXLE_FRONT_X = -(CONFIG.stockLength / 2 - CONFIG.frontAxleFromFront);
let AXLE_REAR_X = CONFIG.stockLength / 2 - CONFIG.rearAxleFromBack;

function getEffectiveAxleHeight() {
  return state.axleMountType === 'drilled' ? state.drilledAxleHeight : CONFIG.axleSlotHeight;
}

function makeRulerLabel(text, size) {
  const s = size || 0.3;
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  const fontSize = 48;
  canvas.width = 128;
  canvas.height = 80;
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = 'rgba(100, 160, 220, 0.85)';
  ctx.font = `bold ${fontSize}px "Share Tech Mono", monospace`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(text, canvas.width / 2, canvas.height / 2);
  const tex = new THREE.CanvasTexture(canvas);
  tex.minFilter = THREE.LinearFilter;
  const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, depthTest: true });
  const sprite = new THREE.Sprite(mat);
  sprite.scale.set(s * 2, s, 1);
  return sprite;
}

function buildRuler() {
  while (rulerGroup.children.length) rulerGroup.remove(rulerGroup.children[0]);

  const { length, width } = state.body;
  const halfL = length / 2, halfW = width / 2;
  const sideGap = 1.2;     // distance from car edge to side rulers
  const endGap = 0.6;      // distance from car ends to end rulers
  const y = -0.42;
  const majorTick = 0.2;
  const minorTick = 0.1;
  const lineColor = 0x3a7abf;
  const accentColor = 0x5a9ad9;

  const lineMat = new THREE.LineBasicMaterial({ color: lineColor, transparent: true, opacity: 0.5, depthTest: true });
  const accentMat = new THREE.LineBasicMaterial({ color: accentColor, transparent: true, opacity: 0.7, depthTest: true });

  const sideZ = halfW + sideGap;   // Z position of side rulers
  const renderOrd = 2;

  function addLine(pts, mat) {
    const line = new THREE.Line(new THREE.BufferGeometry().setFromPoints(pts), mat);
    line.renderOrder = renderOrd;
    rulerGroup.add(line);
  }
  function addLabel(text, x, z, size) {
    const lbl = makeRulerLabel(text, size || 0.22);
    lbl.position.set(x, y, z);
    lbl.renderOrder = renderOrd;
    rulerGroup.add(lbl);
  }

  // ── Side rulers (length markings along both sides) ──
  addLine([new THREE.Vector3(-halfL, y, -sideZ), new THREE.Vector3(halfL, y, -sideZ)], lineMat);
  addLine([new THREE.Vector3(-halfL, y,  sideZ), new THREE.Vector3(halfL, y,  sideZ)], lineMat);

  for (let inch = 0; inch <= length; inch += 0.5) {
    const isMajor = inch % 1 < 0.001;
    const x = -halfL + inch;
    const tl = isMajor ? majorTick : minorTick;
    const mat = isMajor ? accentMat : lineMat;

    // Ticks point inward (toward car)
    addLine([new THREE.Vector3(x, y, -sideZ), new THREE.Vector3(x, y, -sideZ + tl)], mat);
    addLine([new THREE.Vector3(x, y,  sideZ), new THREE.Vector3(x, y,  sideZ - tl)], mat);

    if (isMajor) {
      addLabel(inch + '"', x, -sideZ - 0.25);
      addLabel(inch + '"', x,  sideZ + 0.25);
    }
  }

  // ── Axle position accents on side rulers ──
  const axMat = new THREE.LineBasicMaterial({ color: 0xd97706, transparent: true, opacity: 0.5, depthTest: true });
  [AXLE_FRONT_X, AXLE_REAR_X].forEach(ax => {
    const ext = majorTick + 0.06;
    addLine([new THREE.Vector3(ax, y, -sideZ - 0.04), new THREE.Vector3(ax, y, -sideZ + ext)], axMat);
    addLine([new THREE.Vector3(ax, y,  sideZ + 0.04), new THREE.Vector3(ax, y,  sideZ - ext)], axMat);
  });

  // ── End rulers (width markings at front and rear) ──
  const endXf = -halfL - endGap, endXr = halfL + endGap;
  addLine([new THREE.Vector3(endXf, y, -halfW), new THREE.Vector3(endXf, y, halfW)], lineMat);
  addLine([new THREE.Vector3(endXr, y, -halfW), new THREE.Vector3(endXr, y, halfW)], lineMat);

  for (let w = 0; w <= width + 0.001; w += 0.25) {
    const z = -halfW + w;
    const isMajor = Math.abs(w % 0.5) < 0.001 || Math.abs(w % 0.5 - 0.5) < 0.001;
    const tl = isMajor ? majorTick : minorTick;
    const mat = isMajor ? accentMat : lineMat;

    // Ticks point inward (toward car)
    addLine([new THREE.Vector3(endXf, y, z), new THREE.Vector3(endXf + tl, y, z)], mat);
    addLine([new THREE.Vector3(endXr, y, z), new THREE.Vector3(endXr - tl, y, z)], mat);
  }

}

function buildCar() {
  while (carGroup.children.length) carGroup.remove(carGroup.children[0]);
  weightMeshes.length = 0;

  const { length, width, rearHeight, frontHeight, noseHeight, scoopDepth } = state.body;
  const halfL = length / 2, halfW = width / 2;

  // Recalculate axle positions for current body length
  AXLE_FRONT_X = -(halfL - CONFIG.frontAxleFromFront);
  AXLE_REAR_X = halfL - CONFIG.rearAxleFromBack;

  // Body — curved profile
  const shape = new THREE.Shape();
  shape.moveTo(-halfL, 0);
  shape.lineTo(-halfL, noseHeight);                       // front tip
  shape.lineTo(AXLE_FRONT_X, frontHeight);                // nose taper
  // Scoop between axles: quadratic curve dipping by scoopDepth at midpoint
  const midX = (AXLE_FRONT_X + AXLE_REAR_X) / 2;
  const midLinearH = (frontHeight + rearHeight) / 2;
  const cpY = midLinearH - 2 * scoopDepth;               // control point ensures curve passes through midLinearH - scoopDepth at midpoint
  shape.quadraticCurveTo(midX, cpY, AXLE_REAR_X, rearHeight);
  shape.lineTo(halfL, state.body.tailHeight);             // tapered tail
  shape.lineTo(halfL, 0);
  shape.closePath();

  const extSettings = { depth: width, bevelEnabled: true, bevelThickness: 0.03, bevelSize: 0.03, bevelSegments: 3 };
  const bodyGeo = new THREE.ExtrudeGeometry(shape, extSettings);
  bodyGeo.translate(0, 0, -halfW);
  bodyMesh = new THREE.Mesh(bodyGeo, woodMat);
  bodyMesh.castShadow = true;
  bodyMesh.receiveShadow = true;
  bodyMesh.renderOrder = 1;
  carGroup.add(bodyMesh);

  // Wheels and axles
  function createWheelGroup(isLeftSide) {
    const group = new THREE.Group();
    const wR = CONFIG.wheelDiameter / 2;
    const wW = CONFIG.wheelWidth;
    const hubR = wR * 0.38;
    const hubH = 0.04;
    const boreR = 0.047;
    const hubSide = isLeftSide ? -1 : 1;

    // Main tire body
    const tire = new THREE.Mesh(
      new THREE.CylinderGeometry(wR, wR, wW, 32),
      wheelMat
    );
    group.add(tire);

    // Hub boss on outer face (tapers slightly)
    const hub = new THREE.Mesh(
      new THREE.CylinderGeometry(hubR - 0.01, hubR, hubH, 24),
      wheelMat
    );
    hub.position.y = hubSide * (wW / 2 + hubH / 2);
    group.add(hub);

    // Tread edge rims (raised lip on both tread edges)
    const rimGeo = new THREE.TorusGeometry(wR + 0.001, 0.008, 8, 32);
    const rimA = new THREE.Mesh(rimGeo, wheelMat);
    rimA.position.y = -wW / 2 + 0.01;
    rimA.rotation.x = Math.PI / 2;
    group.add(rimA);
    const rimB = new THREE.Mesh(rimGeo, wheelMat);
    rimB.position.y = wW / 2 - 0.01;
    rimB.rotation.x = Math.PI / 2;
    group.add(rimB);

    // Outer face (hub side) concentric ring
    const outerRing = new THREE.Mesh(
      new THREE.TorusGeometry(wR * 0.65, 0.006, 6, 32),
      wheelMat
    );
    outerRing.position.y = hubSide * (wW / 2 + 0.001);
    outerRing.rotation.x = Math.PI / 2;
    group.add(outerRing);

    // Inner face (car side) concentric rings
    const innerRing1 = new THREE.Mesh(
      new THREE.TorusGeometry(wR * 0.6, 0.006, 6, 32),
      wheelMat
    );
    innerRing1.position.y = -hubSide * (wW / 2 + 0.001);
    innerRing1.rotation.x = Math.PI / 2;
    group.add(innerRing1);
    const innerRing2 = new THREE.Mesh(
      new THREE.TorusGeometry(wR * 0.35, 0.005, 6, 32),
      wheelMat
    );
    innerRing2.position.y = -hubSide * (wW / 2 + 0.001);
    innerRing2.rotation.x = Math.PI / 2;
    group.add(innerRing2);

    // Tread mold seam line
    const seam = new THREE.Mesh(
      new THREE.TorusGeometry(wR + 0.002, 0.003, 4, 32),
      wheelMat
    );
    seam.rotation.x = Math.PI / 2;
    group.add(seam);

    // Bore holes (dark circles on both faces)
    const boreMat = new THREE.MeshStandardMaterial({ color: 0x080808, roughness: 0.9 });
    const boreGeo = new THREE.CircleGeometry(boreR, 16);
    const boreInner = new THREE.Mesh(boreGeo, boreMat);
    boreInner.position.y = -hubSide * (wW / 2 + 0.001);
    boreInner.rotation.x = hubSide * Math.PI / 2;
    group.add(boreInner);
    const boreOuter = new THREE.Mesh(boreGeo, boreMat);
    boreOuter.position.y = hubSide * (wW / 2 + hubH + 0.001);
    boreOuter.rotation.x = -hubSide * Math.PI / 2;
    group.add(boreOuter);

    return group;
  }

  const axleGeo = new THREE.CylinderGeometry(0.04, 0.04, width + 0.3, 8);

  const ww = CONFIG.wheelWidth;
  const positions = {
    fl: { x: AXLE_FRONT_X, z: -halfW - ww / 2 - 0.05 },
    fr: { x: AXLE_FRONT_X, z: halfW + ww / 2 + 0.05 },
    rl: { x: AXLE_REAR_X, z: -halfW - ww / 2 - 0.05 },
    rr: { x: AXLE_REAR_X, z: halfW + ww / 2 + 0.05 },
  };

  const effectiveAxleHeight = getEffectiveAxleHeight();

  for (const [key, pos] of Object.entries(positions)) {
    const ax = state.axles[key];
    const wheel = createWheelGroup(pos.z < 0);
    wheel.rotation.x = Math.PI / 2;
    const axleHeightFromBottom = effectiveAxleHeight;
    let wheelY = axleHeightFromBottom - CONFIG.wheelDiameter / 2;
    if (ax.raised) wheelY += CONFIG.raisedWheelLift;
    wheel.position.set(pos.x, wheelY + CONFIG.wheelDiameter / 2, pos.z);

    if (pos.z < 0) wheel.rotation.y = THREE.MathUtils.degToRad(ax.camber);
    else wheel.rotation.y = THREE.MathUtils.degToRad(-ax.camber);

    if (ax.raised) {
      wheel.traverse(child => {
        if (child.isMesh) {
          child.material = child.material.clone();
          child.material.transparent = true;
          child.material.opacity = 0.35;
        }
      });
    }

    wheel.traverse(child => { if (child.isMesh) child.castShadow = true; });
    carGroup.add(wheel);
    wheelMeshes[key] = wheel;
  }

  ['front', 'rear'].forEach(end => {
    const x = end === 'front' ? AXLE_FRONT_X : AXLE_REAR_X;
    const axle = new THREE.Mesh(axleGeo, axleMat);
    axle.rotation.x = Math.PI / 2;
    axle.position.set(x, effectiveAxleHeight, 0);
    carGroup.add(axle);
  });

  // Weights
  state.weights.forEach(w => {
    let geo, verticalExtent;
    const catItem = w.catalogId ? WEIGHT_CATALOG[w.catalogId] : null;

    if (catItem && catItem.dims) {
      // Use catalog dimensions for precise geometry
      if (catItem.shape === 'box') {
        geo = new THREE.BoxGeometry(catItem.dims.x, catItem.dims.y, catItem.dims.z);
        verticalExtent = catItem.dims.y;
      } else if (catItem.shape === 'cyl') {
        geo = new THREE.CylinderGeometry(catItem.dims.d / 2, catItem.dims.d / 2, catItem.dims.l, 16);
        geo.rotateZ(Math.PI / 2);
        verticalExtent = catItem.dims.d;
      } else if (catItem.shape === 'sphere') {
        geo = new THREE.SphereGeometry(catItem.dims.d / 2, 16, 16);
        verticalExtent = catItem.dims.d;
      } else {
        // putty: heuristic sizing
        const size = Math.pow(w.weight * 0.3, 1 / 3) * 0.6 || 0.2;
        geo = new THREE.BoxGeometry(size * 1.5, size * 0.5, size);
        verticalExtent = size * 0.5;
      }
    } else if (w.type === 'tungsten_cylinder') {
      const d = w.diameter || 0.25;
      const l = w.rodLength || (w.weight / (CONFIG.densityTungsten * Math.PI * (d / 2) * (d / 2)));
      geo = new THREE.CylinderGeometry(d / 2, d / 2, l, 16);
      geo.rotateZ(Math.PI / 2);
      verticalExtent = d;
    } else {
      const size = Math.pow(w.weight * 0.3, 1 / 3) * 0.6 || 0.2;
      if (w.type === 'lead_strip') {
        geo = new THREE.BoxGeometry(size * 2, size * 0.3, size);
        verticalExtent = size * 0.3;
      } else if (w.type === 'steel_bbs') {
        geo = new THREE.SphereGeometry(size / 2, 16, 16);
        verticalExtent = size;
      } else {
        geo = new THREE.BoxGeometry(size, size, size);
        verticalExtent = size;
      }
    }
    const catColor = catItem ? (weightColors[catItem.cat] || 0xdc2626) : null;
    const wColor = catColor || weightColors[w.type] || 0xdc2626;
    const mat = new THREE.MeshStandardMaterial({
      color: wColor,
      metalness: 0.7, roughness: 0.2,
      emissive: wColor,
      emissiveIntensity: 0.3
    });
    if (w.embedded) {
      mat.transparent = true;
      mat.opacity = 0.6;
    }
    const mesh = new THREE.Mesh(geo, mat);
    const wx = w.x - halfL;
    const heightAtWx = getProfileHeight(w.x);
    if (w.embedded) {
      mesh.position.set(wx, heightAtWx - verticalExtent / 2, w.y);
    } else {
      mesh.position.set(wx, heightAtWx + verticalExtent / 2 + 0.01, w.y);
    }
    mesh.castShadow = true;
    carGroup.add(mesh);
    weightMeshes.push(mesh);
  });

  // CoG target marker (green ring — where you WANT the CoG)
  const cogTargetX = AXLE_REAR_X - CONFIG.cogTargetFromRearAxle;
  const targetHeightAtX = getProfileHeight(cogTargetX + halfL);
  const targetRingGeo = new THREE.TorusGeometry(0.12, 0.02, 8, 24);
  const targetRingMat = new THREE.MeshStandardMaterial({ color: 0x22c55e, emissive: 0x22c55e, emissiveIntensity: 0.4 });
  const targetRing = new THREE.Mesh(targetRingGeo, targetRingMat);
  targetRing.rotation.x = Math.PI / 2;
  targetRing.position.set(cogTargetX, targetHeightAtX + 0.15, 0);
  carGroup.add(targetRing);

  // CoG actual marker (red sphere)
  const cog = calculateCoG();
  const cogGeo = new THREE.SphereGeometry(0.08, 16, 16);
  cogMarker = new THREE.Mesh(cogGeo, cogMat);
  const cogHeightAtX = getProfileHeight(cog.x + halfL);
  cogMarker.position.set(cog.x, cogHeightAtX + 0.15, cog.z);
  carGroup.add(cogMarker);

  const lowestWheel = Math.min(...Object.values(wheelMeshes).map(w => w.position.y - CONFIG.wheelDiameter / 2));
  carGroup.position.y = -lowestWheel - 0.4;

  buildRuler();

}

function calculateCoG() {
  const { length, width } = state.body;
  const halfL = length / 2;
  const woodDensity = getWoodDensity();

  // --- Wood body centroid via numerical integration ---
  const N = 100;
  const dx = length / N;
  let solidWeight = 0, solidMomentX = 0;
  for (let i = 0; i < N; i++) {
    const xFromFront = (i + 0.5) * dx;
    const h = getProfileHeight(xFromFront);
    const sliceWeight = h * width * dx * woodDensity;
    solidWeight += sliceWeight;
    solidMomentX += (xFromFront - halfL) * sliceWeight;
  }

  // Subtract cavity contributions from embedded weights (they displace wood)
  let cavityWeight = 0, cavityMomentX = 0, cavityMomentZ = 0;
  state.weights.forEach(w => {
    if (w.embedded) {
      const density = getMaterialDensity(w.type, w.catalogId);
      if (density > 0) {
        const displacedVol = w.weight / density;
        const displacedWood = displacedVol * woodDensity;
        const wx = w.x - halfL;
        cavityWeight += displacedWood;
        cavityMomentX += wx * displacedWood;
        cavityMomentZ += w.y * displacedWood;
      }
    }
  });

  const netWoodWeight = solidWeight - cavityWeight;
  let totalWeight = netWoodWeight;
  let sumX = solidMomentX - cavityMomentX;
  let sumZ = -cavityMomentZ;

  // --- Wheels + Axles ---
  const perAxleWeight = state.wheelAxleWeight / 2;
  totalWeight += state.wheelAxleWeight;
  sumX += AXLE_FRONT_X * perAxleWeight;
  sumX += AXLE_REAR_X * perAxleWeight;

  // --- Added weights ---
  state.weights.forEach(w => {
    const wx = w.x - halfL;
    sumX += wx * w.weight;
    sumZ += w.y * w.weight;
    totalWeight += w.weight;
  });

  // --- Misc weight (paint, glue, etc.) ---
  if (state.miscWeight > 0) {
    const miscWx = state.miscWeightX - halfL;
    sumX += miscWx * state.miscWeight;
    totalWeight += state.miscWeight;
  }

  return {
    x: totalWeight > 0 ? sumX / totalWeight : 0,
    y: 0,
    z: totalWeight > 0 ? sumZ / totalWeight : 0
  };
}

function estimateWoodWeight() {
  const bodyVol = estimateBodyVolume();
  const woodDensity = getWoodDensity();
  let displacedVol = 0;
  state.weights.forEach(w => {
    if (w.embedded) {
      const density = getMaterialDensity(w.type, w.catalogId);
      if (density > 0) displacedVol += w.weight / density;
    }
  });
  return (bodyVol - displacedVol) * woodDensity;
}

function getProfileHeight(xFromFront) {
  const { length, frontHeight, rearHeight, noseHeight, scoopDepth } = state.body;
  const halfL = length / 2;
  const frontAxleDist = CONFIG.frontAxleFromFront;
  const rearAxleDist = length - CONFIG.rearAxleFromBack;

  if (xFromFront <= 0) return noseHeight;
  if (xFromFront >= length) return rearHeight;

  // Nose region: 0 → frontAxle
  if (xFromFront <= frontAxleDist) {
    const t = xFromFront / frontAxleDist;
    return noseHeight + (frontHeight - noseHeight) * t;
  }
  // Scoop region: frontAxle → rearAxle
  if (xFromFront <= rearAxleDist) {
    const span = rearAxleDist - frontAxleDist;
    const t = (xFromFront - frontAxleDist) / span;
    const linearH = frontHeight + (rearHeight - frontHeight) * t;
    return linearH - scoopDepth * 4 * t * (1 - t);
  }
  // Rear region: rearAxle → length (interpolate rearHeight → tailHeight)
  const rearSpan = length - rearAxleDist;
  const tRear = (xFromFront - rearAxleDist) / rearSpan;
  return rearHeight + (state.body.tailHeight - rearHeight) * tRear;
}

function getMaterialDensity(type, catalogId) {
  if (catalogId && WEIGHT_CATALOG[catalogId]) return WEIGHT_CATALOG[catalogId].density;
  if (type === 'tungsten' || type === 'tungsten_cylinder') return CONFIG.densityTungsten;
  if (type === 'lead_strip') return CONFIG.densityLead;
  if (type === 'steel_bbs') return CONFIG.densitySteel;
  return 0;
}

function getWoodDensity() {
  const stockVolume = CONFIG.stockLength * CONFIG.stockWidth * CONFIG.stockHeight;
  return state.rawWoodWeight / stockVolume;
}

function estimateBodyVolume() {
  const { length, width } = state.body;
  const N = 100;
  const dx = length / N;
  let vol = 0;
  for (let i = 0; i < N; i++) {
    const xFromFront = (i + 0.5) * dx;
    vol += getProfileHeight(xFromFront) * width * dx;
  }
  return vol;
}

// ===== ORBIT CONTROLS =====
let isDragging = false, prevMouse = { x: 0, y: 0 };
let spherical = { theta: 0.8, phi: 1.0, radius: 12 };
let targetSpherical = { ...spherical };
let autoRotate = false;

function updateCameraFromSpherical() {
  camera.position.x = spherical.radius * Math.sin(spherical.phi) * Math.cos(spherical.theta);
  camera.position.y = spherical.radius * Math.cos(spherical.phi);
  camera.position.z = spherical.radius * Math.sin(spherical.phi) * Math.sin(spherical.theta);
  camera.lookAt(0, 0, 0);
}
updateCameraFromSpherical();

canvas.addEventListener('pointerdown', e => {
  isDragging = true;
  autoRotate = false;
  prevMouse = { x: e.clientX, y: e.clientY };
});
window.addEventListener('pointerup', () => isDragging = false);
canvas.addEventListener('pointermove', e => {
  if (!isDragging) return;
  const dx = e.clientX - prevMouse.x, dy = e.clientY - prevMouse.y;
  spherical.theta -= dx * 0.008;
  spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi + dy * 0.008));
  prevMouse = { x: e.clientX, y: e.clientY };
  updateCameraFromSpherical();
});
canvas.addEventListener('wheel', e => {
  e.preventDefault();
  spherical.radius = Math.max(4, Math.min(25, spherical.radius + e.deltaY * 0.01));
  updateCameraFromSpherical();
}, { passive: false });

let currentView = null;
function resetCamera() {
  spherical = { theta: 0.8, phi: 1.0, radius: 12 };
  updateCameraFromSpherical();
  clearPresetHighlight();
}
function clearPresetHighlight() {
  currentView = null;
  document.querySelectorAll('.preset-group button').forEach(b => b.classList.remove('active'));
}
function toggleRotate() {
  autoRotate = !autoRotate;
  const btn = document.getElementById('rotate-btn');
  btn.textContent = autoRotate ? '● Auto-Spin' : '○ Auto-Spin';
  btn.classList.toggle('active', autoRotate);
}
function toggleXRay() {
  xrayMode = !xrayMode;
  if (xrayMode && cutawayMode) { cutawayMode = false; applyCutawayState(); }
  woodMat.transparent = xrayMode;
  woodMat.opacity = xrayMode ? 0.2 : 1.0;
  woodMat.depthWrite = true;
  woodMat.needsUpdate = true;
  updateViewModeToggle();
}
function toggleCutaway() {
  cutawayMode = !cutawayMode;
  if (cutawayMode && xrayMode) { xrayMode = false; woodMat.transparent = false; woodMat.opacity = 1.0; woodMat.depthWrite = true; woodMat.needsUpdate = true; }
  applyCutawayState();
  updateViewModeToggle();
}
function applyCutawayState() {
  if (cutawayMode) {
    woodMat.clippingPlanes = [cutawayPlane];
    Object.values(wheelMeshes).forEach(w => {
      if (w.position.z > 0) return;
      w.traverse(child => {
        if (!child.isMesh) return;
        if (!child.material._isCloned) {
          child.material = child.material.clone();
          child.material._isCloned = true;
        }
        child.material.clippingPlanes = [cutawayPlane];
      });
    });
  } else {
    woodMat.clippingPlanes = [];
    Object.values(wheelMeshes).forEach(w => {
      w.traverse(child => {
        if (child.isMesh && child.material.clippingPlanes) child.material.clippingPlanes = [];
      });
    });
  }
  woodMat.needsUpdate = true;
}
function cycleViewMode() {
  if (!xrayMode && !cutawayMode) {
    toggleXRay();
  } else if (xrayMode) {
    toggleXRay();
    toggleCutaway();
  } else {
    toggleCutaway();
  }
}
function updateViewModeToggle() {
  const btn = document.getElementById('view-mode-btn');
  if (xrayMode) {
    btn.textContent = 'X-Ray ▸';
  } else if (cutawayMode) {
    btn.textContent = 'Cutaway ▸';
  } else {
    btn.textContent = 'Full ▸';
  }
}
function setView(view) {
  if (currentView === view) {
    clearPresetHighlight();
    return;
  }
  if (view === 'top') { spherical = { theta: 0, phi: 0.1, radius: 10 }; }
  else if (view === 'side') { spherical = { theta: Math.PI / 2, phi: Math.PI / 2, radius: 10 }; }
  else if (view === 'front') { spherical = { theta: Math.PI, phi: Math.PI / 2, radius: 10 }; }
  updateCameraFromSpherical();
  currentView = view;
  document.querySelectorAll('.preset-group button').forEach(b => b.classList.remove('active'));
  document.getElementById('preset-' + view).classList.add('active');
}

// ===== UI UPDATES =====
function updateBody(prop, val) {
  state.body[prop] = parseFloat(val);
  document.getElementById('val-' + prop).textContent = parseFloat(val).toFixed(2) + '"';
  rebuildAll();
}

function updateWoodWeight() {
  state.rawWoodWeight = parseFloat(document.getElementById('raw-wood-weight').value) || 0;
  rebuildAll();
}

function updateAxle(wheel, prop, val) {
  if (prop === 'raised') state.axles[wheel][prop] = val;
  else state.axles[wheel][prop] = parseFloat(val);
  const dispId = `ax-${wheel}-${prop}`;
  const el = document.getElementById(dispId);
  if (el && prop !== 'raised') el.textContent = parseFloat(val).toFixed(1) + '°';
  rebuildAll();
}

function applyAxlePreset(preset) {
  const p = CONFIG.presets[preset];
  if (p) {
    state.axles = {
      fl: { ...p.fl },
      fr: { ...p.fr },
      rl: { ...p.rl },
      rr: { ...p.rr },
    };
  }
  for (const [key, ax] of Object.entries(state.axles)) {
    const bendEl = document.getElementById(`ax-${key}-bend`);
    const camberEl = document.getElementById(`ax-${key}-camber`);
    const raisedEl = document.getElementById(`ax-${key}-raised`);
    if (bendEl) bendEl.textContent = ax.bend.toFixed(1) + '°';
    if (camberEl) camberEl.textContent = ax.camber.toFixed(1) + '°';
    if (raisedEl) raisedEl.checked = ax.raised;
    const parent = (bendEl || {}).closest && bendEl.closest('.axle-wheel');
    if (parent) {
      const sliders = parent.querySelectorAll('input[type="range"]');
      if (sliders[0]) sliders[0].value = ax.bend;
      if (sliders[1]) sliders[1].value = ax.camber;
    }
  }
  rebuildAll();
}

let viewModeBeforeForm = null; // tracks what mode was active before form opened
let previewWeightId = null;    // id of the temp preview weight

function toggleAddForm() {
  const form = document.getElementById('add-form');
  const isOpening = !form.classList.contains('show');
  form.classList.toggle('show');
  editingWeightId = null;
  document.getElementById('add-weight-btn').textContent = '+ Add Weight';
  document.getElementById('wf-confirm-btn').textContent = 'Confirm';

  if (isOpening) {
    // Save current view mode and enter X-Ray
    viewModeBeforeForm = { xray: xrayMode, cutaway: cutawayMode };
    if (!xrayMode) toggleXRay();
    initCatalogForm();
    previewWeight(); // start preview
  } else {
    // Remove preview and restore view mode
    removePreviewWeight();
    restoreViewMode();
  }
}

function removePreviewWeight() {
  if (previewWeightId !== null) {
    state.weights = state.weights.filter(w => w.id !== previewWeightId);
    previewWeightId = null;
    rebuildAll();
  }
}

function restoreViewMode() {
  if (viewModeBeforeForm) {
    if (xrayMode && !viewModeBeforeForm.xray) toggleXRay();
    else if (!xrayMode && viewModeBeforeForm.xray) toggleXRay();
    if (cutawayMode && !viewModeBeforeForm.cutaway) toggleCutaway();
    else if (!cutawayMode && viewModeBeforeForm.cutaway) toggleCutaway();
    viewModeBeforeForm = null;
  }
}

function previewWeight() {
  const form = document.getElementById('add-form');
  if (!form.classList.contains('show')) return;

  const type = getFormType();
  const catalogId = currentCatalogId;
  const x = parseFloat(document.getElementById('wf-x').value);
  const y = parseFloat(document.getElementById('wf-y').value);
  const embedded = document.getElementById('wf-embedded').checked;
  const weight = parseFloat(document.getElementById('wf-weight').value) || 0;
  const qty = parseInt(document.getElementById('wf-qty').value) || 1;

  // Build catalog-aware weight props
  const catItem = catalogId ? WEIGHT_CATALOG[catalogId] : null;
  const extraProps = { catalogId: catalogId || undefined };
  if (catItem && catItem.shape === 'cyl' && catItem.dims) {
    extraProps.diameter = catItem.dims.d;
    extraProps.rodLength = catItem.dims.l;
  }

  if (editingWeightId !== null) {
    const w = state.weights.find(item => item.id === editingWeightId);
    if (w) {
      Object.assign(w, { x, y, weight, type, embedded, ...extraProps });
    }
  } else {
    if (previewWeightId !== null) {
      const pw = state.weights.find(item => item.id === previewWeightId);
      if (pw) {
        Object.assign(pw, { x, y, weight, type, embedded, ...extraProps });
      }
    } else if (weight > 0) {
      previewWeightId = -999;
      state.weights.push({ id: previewWeightId, name: '(preview)', type, weight, x, y, embedded, ...extraProps });
    }
  }
  rebuildAll();
}

// Legacy support functions (kept for migration)
function updateCylinderFields() {}
function computeRodWeight() {}

// ===== CATALOG FORM FUNCTIONS =====
let currentCatalogId = null;

function initCatalogForm() {
  const catSel = document.getElementById('wf-category');
  catSel.innerHTML = CATALOG_CATEGORIES.map(c =>
    `<option value="${c.key}">${c.label}</option>`
  ).join('');
  updateCatalogProducts();
}

function updateCatalogProducts() {
  const cat = document.getElementById('wf-category').value;
  const prodSel = document.getElementById('wf-product');
  const items = Object.entries(WEIGHT_CATALOG).filter(([k, v]) => v.cat === cat);
  prodSel.innerHTML = items.map(([id, item]) => {
    const wt = getCatalogWeight(id);
    const wtText = wt > 0 ? ` — ${wt.toFixed(3)} oz` : '';
    return `<option value="${id}">${item.name}${wtText}</option>`;
  }).join('');
  selectCatalogProduct();
}

function selectCatalogProduct() {
  const id = document.getElementById('wf-product').value;
  currentCatalogId = id;
  const item = WEIGHT_CATALOG[id];
  if (!item) return;

  const weightInput = document.getElementById('wf-weight');
  const weightNote = document.getElementById('wf-weight-note');
  const dimsDisplay = document.getElementById('wf-dims-display');
  const qtyRow = document.getElementById('wf-qty-row');

  // Show qty for BBs and small items
  qtyRow.style.display = (item.cat === 'bb') ? '' : 'none';
  if (item.cat !== 'bb') document.getElementById('wf-qty').value = 1;

  // Set weight
  const qty = parseInt(document.getElementById('wf-qty').value) || 1;
  const unitWeight = getCatalogWeight(id);
  if (item.userWeight) {
    weightInput.readOnly = false;
    weightInput.style.opacity = '1';
    weightNote.textContent = '(enter weight)';
    if (!weightInput.value || parseFloat(weightInput.value) === 0) weightInput.value = '0.25';
  } else {
    const totalWt = unitWeight * qty;
    weightInput.value = totalWt.toFixed(3);
    weightInput.readOnly = true;
    weightInput.style.opacity = '0.7';
    weightNote.textContent = '(from catalog)';
  }

  // Dims display
  dimsDisplay.textContent = getCatalogDimsText(id);

  // Default embedded state
  document.getElementById('wf-embedded').checked = item.embed;

  updateNetWeightDisplay();
  checkBodyFit();
  previewWeight();
}

function updateQtyWeight() {
  const id = currentCatalogId;
  const item = WEIGHT_CATALOG[id];
  if (!item || item.userWeight) return;
  const qty = parseInt(document.getElementById('wf-qty').value) || 1;
  const unitWeight = getCatalogWeight(id);
  document.getElementById('wf-weight').value = (unitWeight * qty).toFixed(3);
}

function updateNetWeightDisplay() {
  const el = document.getElementById('wf-net-weight');
  const embedded = document.getElementById('wf-embedded').checked;
  const weight = parseFloat(document.getElementById('wf-weight').value) || 0;
  const id = currentCatalogId;

  if (!embedded || weight <= 0) { el.textContent = ''; return; }

  const density = id && WEIGHT_CATALOG[id] ? WEIGHT_CATALOG[id].density : getMaterialDensity('tungsten');
  if (density <= 0) { el.textContent = ''; return; }

  const woodDensity = getWoodDensity();
  const displacedVol = weight / density;
  const displacedWood = displacedVol * woodDensity;
  const netAdd = weight - displacedWood;

  el.innerHTML = `Net +${netAdd.toFixed(3)} oz (displaces ${displacedWood.toFixed(3)} oz wood)`;
  el.style.color = 'var(--text-dim)';
}

function getFormType() {
  // Map catalog category back to legacy type for weight objects
  const id = currentCatalogId;
  if (!id) return 'custom';
  const item = WEIGHT_CATALOG[id];
  if (!item) return 'custom';
  if (item.cat === 'cube') return 'tungsten';
  if (item.cat === 'rod') return 'tungsten_cylinder';
  if (item.cat === 'lead' || item.cat === 'plate') return 'lead_strip';
  if (item.cat === 'bb') return 'steel_bbs';
  if (item.cat === 'putty') return 'tungsten';
  return 'custom';
}

function getWeightVerticalExtent(catalogId, weight) {
  const item = catalogId ? WEIGHT_CATALOG[catalogId] : null;
  if (item && item.dims) {
    if (item.shape === 'box') return item.dims.y;
    if (item.shape === 'cyl') return item.dims.d;
    if (item.shape === 'sphere') return item.dims.d;
  }
  // Fallback: estimate from weight
  return Math.pow((weight || 0.25) * 0.3, 1/3) * 0.6 || 0.2;
}

function getWeightLengthExtent(catalogId, weight) {
  const item = catalogId ? WEIGHT_CATALOG[catalogId] : null;
  if (item && item.dims) {
    if (item.shape === 'box') return item.dims.x;
    if (item.shape === 'cyl') return item.dims.l;
    if (item.shape === 'sphere') return item.dims.d;
  }
  return Math.pow((weight || 0.25) * 0.3, 1/3) * 0.6 || 0.2;
}

function checkBodyFit() {
  const warningEl = document.getElementById('wf-fit-warning');
  if (!warningEl) return;
  warningEl.innerHTML = '';

  const embedded = document.getElementById('wf-embedded').checked;
  if (!embedded) return;

  const x = parseFloat(document.getElementById('wf-x').value);
  const weight = parseFloat(document.getElementById('wf-weight').value) || 0;
  const id = currentCatalogId;
  const { length, width } = state.body;

  const vExt = getWeightVerticalExtent(id, weight);
  const lExt = getWeightLengthExtent(id, weight);

  const warnings = [];

  // Check body height across the weight's length span
  const startX = Math.max(0, x - lExt / 2);
  const endX = Math.min(length, x + lExt / 2);
  const samples = 5;
  for (let i = 0; i <= samples; i++) {
    const sx = startX + (endX - startX) * (i / samples);
    const h = getProfileHeight(sx);
    if (h < vExt) {
      warnings.push(`Body too shallow at ${sx.toFixed(1)}" (${h.toFixed(2)}" height) for ${vExt.toFixed(3)}" embedded weight`);
      break;
    }
  }

  // Check if weight extends past body length
  if (x - lExt / 2 < 0) warnings.push('Weight extends past front of car');
  if (x + lExt / 2 > length) warnings.push('Weight extends past rear of car');

  // Check width for rods
  const item = id ? WEIGHT_CATALOG[id] : null;
  if (item && item.shape === 'cyl' && item.dims && item.dims.l > width) {
    warnings.push(`Rod length (${item.dims.l}") exceeds body width (${width.toFixed(2)}")`);
  }

  if (warnings.length > 0) {
    warningEl.innerHTML = warnings.map(w =>
      `<div style="color:var(--amber);padding:2px 0;">&#9888; ${w}</div>`
    ).join('');
  }
}

function formatDiameter(d) {
  if (d === 0.25) return '1/4"';
  if (d === 0.375) return '3/8"';
  if (d === 0.5) return '1/2"';
  return d + '"';
}

function addWeight() {
  const type = getFormType();
  const catalogId = currentCatalogId;
  const catItem = catalogId ? WEIGHT_CATALOG[catalogId] : null;
  const name = document.getElementById('wf-name').value || (catItem ? catItem.name : 'Weight ' + state.nextId);
  const x = parseFloat(document.getElementById('wf-x').value);
  const y = parseFloat(document.getElementById('wf-y').value);
  const embedded = document.getElementById('wf-embedded').checked;
  const weight = parseFloat(document.getElementById('wf-weight').value) || 0;

  // Remove preview weight first
  if (previewWeightId !== null) {
    state.weights = state.weights.filter(w => w.id !== previewWeightId);
    previewWeightId = null;
  }

  const extraProps = { catalogId: catalogId || undefined };
  if (catItem && catItem.shape === 'cyl' && catItem.dims) {
    extraProps.diameter = catItem.dims.d;
    extraProps.rodLength = catItem.dims.l;
  }

  if (editingWeightId !== null) {
    const w = state.weights.find(item => item.id === editingWeightId);
    if (w) {
      Object.assign(w, { name, type, x, y, embedded, weight, ...extraProps });
    }
    editingWeightId = null;
  } else {
    state.weights.push({ id: state.nextId++, name, type, weight, x, y, embedded, ...extraProps });
  }
  document.getElementById('wf-name').value = '';
  document.getElementById('wf-embedded').checked = false;
  document.getElementById('wf-net-weight').textContent = '';
  document.getElementById('wf-fit-warning').innerHTML = '';
  // Close form and restore view mode
  document.getElementById('add-form').classList.remove('show');
  document.getElementById('add-weight-btn').textContent = '+ Add Weight';
  document.getElementById('wf-confirm-btn').textContent = 'Confirm';
  restoreViewMode();
  rebuildAll();
}

let editingWeightId = null;

function removeWeight(id) {
  state.weights = state.weights.filter(w => w.id !== id);
  if (editingWeightId === id) { editingWeightId = null; }
  rebuildAll();
}

function editWeight(id) {
  const w = state.weights.find(item => item.id === id);
  if (!w) return;
  editingWeightId = id;
  document.getElementById('wf-name').value = w.name;

  // Restore catalog selections if weight has catalogId
  if (w.catalogId && WEIGHT_CATALOG[w.catalogId]) {
    const catItem = WEIGHT_CATALOG[w.catalogId];
    document.getElementById('wf-category').value = catItem.cat;
    updateCatalogProducts();
    document.getElementById('wf-product').value = w.catalogId;
    currentCatalogId = w.catalogId;
  } else {
    // Legacy weight: map type to category
    const catMap = { tungsten: 'cube', tungsten_cylinder: 'rod', lead_strip: 'lead', steel_bbs: 'bb', custom: 'custom' };
    document.getElementById('wf-category').value = catMap[w.type] || 'custom';
    updateCatalogProducts();
    currentCatalogId = document.getElementById('wf-product').value;
  }

  document.getElementById('wf-weight').value = w.weight;
  document.getElementById('wf-weight').readOnly = false;
  document.getElementById('wf-weight').style.opacity = '1';
  document.getElementById('wf-x').value = w.x;
  document.getElementById('wf-y').value = w.y;
  document.getElementById('wf-x-val').textContent = w.x.toFixed(1) + '"';
  document.getElementById('wf-y-val').textContent = w.y.toFixed(1) + '"';
  document.getElementById('wf-embedded').checked = w.embedded;
  updateNetWeightDisplay();
  checkBodyFit();
  const form = document.getElementById('add-form');
  if (!form.classList.contains('show')) {
    viewModeBeforeForm = { xray: xrayMode, cutaway: cutawayMode };
    if (!xrayMode) toggleXRay();
    form.classList.add('show');
  }
  document.getElementById('add-weight-btn').textContent = 'Cancel Edit';
  document.getElementById('wf-confirm-btn').textContent = 'Save';
}

function autoOptimizeX() {
  const { length } = state.body;
  const halfL = length / 2;
  const weight = parseFloat(document.getElementById('wf-weight').value) || 0;
  const type = getFormType();
  const embedded = document.getElementById('wf-embedded').checked;
  if (weight <= 0) { alert('Enter a weight first.'); return; }

  const cog = calculateCoG();
  const currentCogX = cog.x;
  const currentTotal = estimateWoodWeight() + state.wheelAxleWeight + (state.miscWeight || 0) + state.weights.reduce((s, w) => s + w.weight, 0);
  const targetCogX = AXLE_REAR_X - CONFIG.cogTargetFromRearAxle;

  // Effective weight accounts for wood displacement if embedded
  let effectiveWeight = weight;
  if (embedded) {
    const density = getMaterialDensity(type, currentCatalogId);
    if (density > 0) {
      const woodDensity = getWoodDensity();
      effectiveWeight = weight - (weight / density) * woodDensity;
    }
  }

  // Solve: targetCogX = (currentCogX * currentTotal + wx * effectiveWeight) / (currentTotal + effectiveWeight)
  const optimalWx = (targetCogX * (currentTotal + effectiveWeight) - currentCogX * currentTotal) / effectiveWeight;
  const optimalXFromFront = optimalWx + halfL;

  if (optimalXFromFront < 0 || optimalXFromFront > length) {
    alert(`Optimal position (${optimalXFromFront.toFixed(2)}" from front) is outside the car body. Consider adjusting weight or other parameters.`);
  }

  const clamped = Math.max(0, Math.min(length, optimalXFromFront));
  document.getElementById('wf-x').value = clamped.toFixed(1);
  document.getElementById('wf-x-val').textContent = clamped.toFixed(1) + '"';
  previewWeight();
}

function applyAutoWeight() {
  const { length } = state.body;
  const halfL = length / 2;

  // Filter out preview weight for calculations
  const realWeights = state.weights.filter(w => w.id !== previewWeightId);
  const woodWt = estimateWoodWeight();
  const addedWt = realWeights.reduce((s, w) => s + w.weight, 0);
  const miscWt = state.miscWeight || 0;
  const currentTotal = woodWt + addedWt + state.wheelAxleWeight + miscWt;
  const remaining = state.maxWeight - currentTotal;

  if (remaining <= 0.01) {
    document.getElementById('auto-weight-result').innerHTML =
      '<div class="alignment-note" style="border-left-color:var(--race-red)"><strong>At max weight.</strong> Remove existing weights to add more.</div>';
    return;
  }

  // Calculate where to put `remaining` oz to hit target COG
  const cog = calculateCoG();
  const currentCogX = cog.x;
  const targetCogX = AXLE_REAR_X - CONFIG.cogTargetFromRearAxle;
  const optimalWx = (targetCogX * (currentTotal + remaining) - currentCogX * currentTotal) / remaining;
  const optimalXFromFront = optimalWx + halfL;
  const clamped = Math.max(0.5, Math.min(length - 0.5, optimalXFromFront));

  // Show result
  document.getElementById('auto-weight-result').innerHTML =
    `<div class="alignment-note" style="border-left-color:var(--green)">
      <strong>Recommended:</strong> Add <span style="color:var(--amber)">${remaining.toFixed(2)} oz</span> at <span style="color:var(--amber)">${clamped.toFixed(1)}"</span> from front (embedded tungsten).<br>
      This fills to ${state.maxWeight.toFixed(2)} oz and targets COG at ${CONFIG.cogTargetFromRearAxle.toFixed(2)}" fwd of rear axle.
    </div>`;

  // Pre-fill the add form with these values
  document.getElementById('wf-name').value = 'Auto ballast';
  initCatalogForm();
  document.getElementById('wf-category').value = 'cube';
  updateCatalogProducts();
  document.getElementById('wf-weight').value = remaining.toFixed(3);
  document.getElementById('wf-weight').readOnly = false;
  document.getElementById('wf-weight').style.opacity = '1';
  document.getElementById('wf-x').value = clamped.toFixed(1);
  document.getElementById('wf-x-val').textContent = clamped.toFixed(1) + '"';
  document.getElementById('wf-y').value = '0';
  document.getElementById('wf-y-val').textContent = '0.0"';
  document.getElementById('wf-embedded').checked = true;

  // Open the form (will trigger X-Ray + preview)
  const form = document.getElementById('add-form');
  if (!form.classList.contains('show')) {
    viewModeBeforeForm = { xray: xrayMode, cutaway: cutawayMode };
    if (!xrayMode) toggleXRay();
    form.classList.add('show');
  }
  previewWeight();
}

function updateAutoWeightDisplay() {
  const realWeights = state.weights.filter(w => w.id !== previewWeightId);
  const woodWt = estimateWoodWeight();
  const addedWt = realWeights.reduce((s, w) => s + w.weight, 0);
  const miscWt = state.miscWeight || 0;
  const currentTotal = woodWt + addedWt + state.wheelAxleWeight + miscWt;
  const remaining = state.maxWeight - currentTotal;
  const btn = document.getElementById('auto-weight-btn');
  if (remaining > 0.01) {
    btn.textContent = `Add ${remaining.toFixed(2)} oz — Optimal Placement`;
    btn.style.display = '';
  } else {
    btn.textContent = 'At Max Weight';
    btn.style.opacity = '0.5';
  }
}

function renderWeightList() {
  const list = document.getElementById('weight-list');
  const visible = state.weights.filter(w => w.id !== -999);
  if (visible.length === 0) {
    list.innerHTML = '<p style="font-family:\'Share Tech Mono\',monospace;font-size:0.72rem;color:var(--text-muted);padding:12px 0;letter-spacing:0.5px;">No weights added. Click "+ Add Weight" to begin.</p>';
    return;
  }
  list.innerHTML = visible.map((w, i) => {
    let desc;
    if (w.catalogId && WEIGHT_CATALOG[w.catalogId]) {
      desc = WEIGHT_CATALOG[w.catalogId].name;
    } else if (w.type === 'tungsten_cylinder' && w.diameter) {
      desc = formatDiameter(w.diameter) + ' × ' + w.rodLength + '" rod';
    } else {
      desc = w.type.replace('_', ' ');
    }
    return `<div class="weight-item" style="animation-delay:${i * 0.05}s">
      <div class="info">
        <span class="name">${w.name}</span>
        <span class="detail">${desc} // ${w.weight.toFixed(2)} oz // ${w.x.toFixed(1)}" from front${w.embedded ? ' [EMB]' : ''}</span>
      </div>
      <div class="actions">
        <button class="btn btn-secondary btn-sm" onclick="editWeight(${w.id})">EDIT</button>
        <button class="btn btn-secondary btn-sm" onclick="removeWeight(${w.id})">DEL</button>
      </div>
    </div>`;
  }).join('');
}

function updateWeightDisplay() {
  const woodWt = estimateWoodWeight();
  const addedWt = state.weights.reduce((s, w) => s + w.weight, 0);
  const miscWt = state.miscWeight || 0;
  const total = woodWt + addedWt + state.wheelAxleWeight + miscWt;
  const remaining = state.maxWeight - total;
  const pct = Math.min(100, (total / state.maxWeight) * 100);

  // Weight gauge
  const weightVal = document.getElementById('weight-text');
  weightVal.innerHTML = `${total.toFixed(2)}<span style="font-size:0.9rem;color:var(--text-dim)"> / ${state.maxWeight.toFixed(2)} oz</span>`;

  const fill = document.getElementById('weight-fill');
  fill.style.width = pct + '%';
  fill.style.background = total > state.maxWeight
    ? 'linear-gradient(90deg, var(--race-red), #ff4444)'
    : total > (state.maxWeight - CONFIG.warningThreshold)
      ? 'linear-gradient(90deg, var(--amber-dim), var(--amber))'
      : 'linear-gradient(90deg, var(--green-dim), var(--green))';

  // Status light
  const light = document.getElementById('status-light');
  light.className = 'status-light';
  if (total > state.maxWeight) light.classList.add('danger');
  else if (total > (state.maxWeight - CONFIG.warningThreshold)) light.classList.add('warning');

  document.getElementById('val-cut-weight').textContent = woodWt.toFixed(2) + ' oz';
  document.getElementById('val-removed').textContent = (state.rawWoodWeight - woodWt).toFixed(2) + ' oz';
  document.getElementById('wt-wood').textContent = woodWt.toFixed(2) + ' oz';
  document.getElementById('wt-added').textContent = addedWt.toFixed(2) + ' oz';

  // Displacement display
  const woodDensity = getWoodDensity();
  let totalDisplaced = 0;
  state.weights.forEach(w => {
    if (w.embedded) {
      const density = getMaterialDensity(w.type, w.catalogId);
      if (density > 0) totalDisplaced += (w.weight / density) * woodDensity;
    }
  });
  const displacedRow = document.getElementById('wt-displaced-row');
  if (totalDisplaced > 0.001) {
    displacedRow.style.display = '';
    document.getElementById('wt-displaced').textContent = '-' + totalDisplaced.toFixed(2) + ' oz';
  } else {
    displacedRow.style.display = 'none';
  }

  document.getElementById('wt-total').textContent = total.toFixed(2) + ' oz';
  document.getElementById('wt-total').style.color = total > state.maxWeight ? 'var(--race-red)' : 'var(--green)';
  document.getElementById('wt-remaining').textContent = remaining >= 0 ? remaining.toFixed(2) + ' oz' : 'OVER by ' + Math.abs(remaining).toFixed(2) + ' oz';
  document.getElementById('wt-remaining').style.color = remaining >= 0 ? 'var(--amber)' : 'var(--race-red)';

  const cog = calculateCoG();
  const halfL = state.body.length / 2;
  // Distance from rear axle (positive = in front of rear axle)
  const fromRearAxle = AXLE_REAR_X - cog.x;
  const cogTargetFromRearAxle = CONFIG.cogTargetFromRearAxle;
  const cogDelta = fromRearAxle - cogTargetFromRearAxle;
  const cogOnTarget = Math.abs(cogDelta) < CONFIG.cogToleranceGreen;

  // Header COG display
  const headerCogText = document.getElementById('header-cog-text');
  const absDelta = Math.abs(cogDelta).toFixed(2);
  if (cogOnTarget) {
    headerCogText.textContent = 'On target';
  } else if (cogDelta > 0) {
    headerCogText.textContent = `${absDelta}" in front of target`;
  } else {
    headerCogText.textContent = `${absDelta}" behind target`;
  }
  headerCogText.style.color = cogOnTarget ? 'var(--green)' : 'var(--amber)';
  const cogLight = document.getElementById('cog-status-light');
  cogLight.className = 'status-light' + (cogOnTarget ? '' : ' warning');

  document.getElementById('dim-l').textContent = state.body.length.toFixed(2) + '"';
  document.getElementById('dim-w').textContent = state.body.width.toFixed(2) + '"';
  document.getElementById('dim-h').textContent = Math.max(state.body.rearHeight, state.body.frontHeight, state.body.noseHeight).toFixed(2) + '"';
  // Ground clearance: wheel bottom on ground, axle center at wheelRadius above ground,
  // block bottom at (wheelRadius - axleHeight) above ground
  const effAxleH = getEffectiveAxleHeight();
  const groundClearance = CONFIG.wheelDiameter / 2 - effAxleH;
  document.getElementById('dim-c').textContent = '~' + groundClearance.toFixed(2) + '"';
}

function updateRules() {
  const { length, width, rearHeight, frontHeight } = state.body;
  const total = estimateWoodWeight() + state.weights.reduce((s, w) => s + w.weight, 0) + state.wheelAxleWeight + (state.miscWeight || 0);
  const clearance = CONFIG.wheelDiameter / 2 - getEffectiveAxleHeight();

  const rules = [
    { pass: length <= CONFIG.maxLength, text: `Length ≤ ${CONFIG.maxLength}" — current: ${length.toFixed(2)}"` },
    { pass: width <= CONFIG.maxWidth, text: `Width ≤ ${CONFIG.maxWidth}" — current: ${width.toFixed(2)}"` },
    { pass: width >= CONFIG.minWidth, text: `Width between wheels ≥ ${CONFIG.minWidth}" — current: ${width.toFixed(2)}"` },
    { pass: total <= CONFIG.maxWeight, text: `Weight ≤ ${CONFIG.maxWeight} oz — current: ${total.toFixed(2)} oz` },
    { pass: clearance >= CONFIG.minClearance, text: `Bottom clearance ≥ ${CONFIG.minClearance}" — est: ${clearance.toFixed(3)}"` },
    { pass: true, text: 'Front does not project past starting post' },
    { pass: length <= CONFIG.maxLength, text: `No decorations past ${CONFIG.maxLength}" overall length` },
    { pass: true, text: 'Using Pack 3 supplied wood block, axles & wheels' },
  ];

  const allPass = rules.every(r => r.pass);
  const dot = document.getElementById('rules-status-dot');
  dot.className = 'rules-status ' + (allPass ? 'pass' : 'fail');

  document.getElementById('rules-list').innerHTML = rules.map((r, i) => `
    <div class="rule-item ${r.pass ? 'rule-pass' : 'rule-fail'}" style="animation-delay:${i * 0.06}s">
      <span class="rule-icon">${r.pass ? 'P' : 'F'}</span>
      <span class="rule-text">${r.text}</span>
    </div>
  `).join('');
}

function updateWheelAxleWeight() {
  state.wheelAxleWeight = parseFloat(document.getElementById('wheel-axle-weight').value) || 0;
  rebuildAll();
}

function updateMiscWeight() {
  state.miscWeight = parseFloat(document.getElementById('misc-weight').value) || 0;
  document.getElementById('misc-weight-x-row').style.display = state.miscWeight > 0 ? '' : 'none';
  rebuildAll();
}

function updateMiscWeightX(val) {
  state.miscWeightX = parseFloat(val);
  document.getElementById('misc-weight-x-val').textContent = state.miscWeightX.toFixed(1) + '"';
  rebuildAll();
}

function updateAxleMountType(type) {
  state.axleMountType = type;
  document.getElementById('drilled-options').style.display = type === 'drilled' ? 'block' : 'none';
  document.getElementById('slot-info').style.display = type === 'slot' ? 'block' : 'none';
  rebuildAll();
}

function updateDrilledHeight(val) {
  const maxH = CONFIG.wheelDiameter / 2 - CONFIG.minClearance;
  state.drilledAxleHeight = Math.min(parseFloat(val), maxH);
  document.getElementById('val-drilled-height').textContent = state.drilledAxleHeight.toFixed(3) + '"';
  const clr = CONFIG.wheelDiameter / 2 - state.drilledAxleHeight;
  document.getElementById('val-drilled-clearance').textContent = clr.toFixed(3) + '"';
  document.getElementById('val-drilled-clearance').style.color = clr >= CONFIG.minClearance ? 'var(--green)' : 'var(--race-red)';
  rebuildAll();
}

// ===== WEIGHT PLANNER =====
let plannerResults = []; // [{catalogId, weight, x, fit}]

function initPlannerDropdowns() {
  const catSel = document.getElementById('planner-add-cat');
  if (!catSel) return;
  catSel.innerHTML = CATALOG_CATEGORIES.filter(c => c.key !== 'custom').map(c =>
    `<option value="${c.key}">${c.label}</option>`
  ).join('');
  updatePlannerProductOptions();
}

function updatePlannerProductOptions() {
  const cat = document.getElementById('planner-add-cat').value;
  const prodSel = document.getElementById('planner-add-product');
  const items = Object.entries(WEIGHT_CATALOG).filter(([k, v]) => v.cat === cat && !v.userWeight);
  prodSel.innerHTML = items.map(([id, item]) => {
    const wt = getCatalogWeight(id);
    return `<option value="${id}">${item.name} — ${wt.toFixed(3)} oz</option>`;
  }).join('');
  // Also show user-weight items
  const userItems = Object.entries(WEIGHT_CATALOG).filter(([k, v]) => v.cat === cat && v.userWeight);
  userItems.forEach(([id, item]) => {
    prodSel.innerHTML += `<option value="${id}">${item.name}</option>`;
  });
}

function addPlannerItem() {
  const catalogId = document.getElementById('planner-add-product').value;
  if (!catalogId) return;
  if (!state.plannerItems) state.plannerItems = [];
  state.plannerItems.push({ catalogId, qty: 1, customWeight: null });
  renderPlanner();
  saveState();
}

function removePlannerItem(index) {
  state.plannerItems.splice(index, 1);
  plannerResults = [];
  renderPlanner();
  saveState();
}

function updatePlannerQty(index, val) {
  state.plannerItems[index].qty = Math.max(1, parseInt(val) || 1);
  renderPlanner();
  saveState();
}

function updatePlannerCustomWeight(index, val) {
  state.plannerItems[index].customWeight = parseFloat(val) || 0;
  renderPlanner();
  saveState();
}

function getPlannerItemWeight(item) {
  const catWt = getCatalogWeight(item.catalogId);
  if (catWt > 0) return catWt * (item.qty || 1);
  return (item.customWeight || 0) * (item.qty || 1);
}

function renderPlanner() {
  const realWeights = state.weights.filter(w => w.id !== previewWeightId);
  const woodWt = estimateWoodWeight();
  const addedWt = realWeights.reduce((s, w) => s + w.weight, 0);
  const miscWt = state.miscWeight || 0;
  const currentTotal = woodWt + addedWt + state.wheelAxleWeight + miscWt;
  const remaining = state.maxWeight - currentTotal;

  const budgetEl = document.getElementById('planner-budget');
  budgetEl.innerHTML = `Budget: <span style="color:${remaining >= 0 ? 'var(--amber)' : 'var(--race-red)'}">${remaining.toFixed(2)} oz</span> remaining`;

  const itemsEl = document.getElementById('planner-items');
  if (!state.plannerItems || state.plannerItems.length === 0) {
    itemsEl.innerHTML = '<div style="font-size:0.72rem;color:var(--text-muted);padding:4px 0;">No items in plan. Add products below.</div>';
  } else {
    itemsEl.innerHTML = state.plannerItems.map((item, i) => {
      const cat = WEIGHT_CATALOG[item.catalogId];
      const name = cat ? cat.name : item.catalogId;
      const wt = getPlannerItemWeight(item);
      const isUserWeight = cat && cat.userWeight;
      const result = plannerResults[i];
      const fitWarn = result && !result.fit ? ' <span style="color:var(--amber)">&#9888;</span>' : '';
      return `<div style="display:flex;align-items:center;gap:6px;padding:4px 0;border-bottom:1px solid var(--border);font-size:0.78rem;">
        <span style="flex:1;color:var(--text);">${name}${fitWarn}</span>
        ${isUserWeight ? `<input type="number" value="${item.customWeight || 0}" step="0.01" min="0" max="3" style="width:60px;" oninput="updatePlannerCustomWeight(${i},this.value)">` : ''}
        ${cat && cat.cat === 'bb' ? `<input type="number" value="${item.qty}" min="1" max="50" style="width:42px;" oninput="updatePlannerQty(${i},this.value)">` : ''}
        <span style="color:var(--amber);font-family:'Share Tech Mono',monospace;min-width:55px;text-align:right;">${wt.toFixed(2)} oz</span>
        <button class="btn btn-secondary btn-sm" onclick="removePlannerItem(${i})" style="padding:2px 6px;font-size:0.65rem;">X</button>
      </div>`;
    }).join('');
  }

  const planTotal = (state.plannerItems || []).reduce((s, item) => s + getPlannerItemWeight(item), 0);
  const totalEl = document.getElementById('planner-total');
  totalEl.innerHTML = `Plan total: <span style="color:var(--amber)">${planTotal.toFixed(2)} oz</span>`;

  const warnEl = document.getElementById('planner-warning');
  if (planTotal > remaining + 0.01) {
    warnEl.innerHTML = `<span style="color:var(--race-red);">&#9888; Over budget by ${(planTotal - remaining).toFixed(2)} oz</span>`;
  } else if (planTotal > 0 && planTotal <= remaining) {
    warnEl.innerHTML = `<span style="color:var(--green);">Within budget (${(remaining - planTotal).toFixed(2)} oz to spare)</span>`;
  } else {
    warnEl.innerHTML = '';
  }

  // Show/hide apply button based on results
  document.getElementById('planner-apply-btn').style.display = plannerResults.length > 0 ? '' : 'none';

  // Render results
  const resultsEl = document.getElementById('planner-results');
  if (plannerResults.length > 0) {
    const projectedTotal = currentTotal + plannerResults.reduce((s, r) => s + r.weight, 0);
    // Compute projected COG
    let html = plannerResults.map((r, i) => {
      const icon = r.fit ? '<span style="color:var(--green);">&#10003;</span>' : '<span style="color:var(--amber);">&#9888;</span>';
      const cat = WEIGHT_CATALOG[r.catalogId];
      return `<div>${icon} ${cat ? cat.name : r.catalogId} → ${r.x.toFixed(1)}" embedded</div>`;
    }).join('');
    html += `<div style="margin-top:4px;color:var(--text-dim);">Projected: ${projectedTotal.toFixed(2)} oz</div>`;
    resultsEl.innerHTML = html;
  } else {
    resultsEl.innerHTML = '';
  }
}

function runOptimizer() {
  if (!state.plannerItems || state.plannerItems.length === 0) return;

  const { length } = state.body;
  const halfL = length / 2;
  const woodDensity = getWoodDensity();

  // Current state (without planner weights)
  const realWeights = state.weights.filter(w => w.id !== previewWeightId);
  let currentTotal = estimateWoodWeight() + state.wheelAxleWeight + (state.miscWeight || 0) + realWeights.reduce((s, w) => s + w.weight, 0);
  let currentCogX = calculateCoG().x;
  const targetCogX = AXLE_REAR_X - CONFIG.cogTargetFromRearAxle;

  // Sort by weight descending (heaviest first for most COG influence)
  const sorted = state.plannerItems.map((item, i) => ({ ...item, origIndex: i, weight: getPlannerItemWeight(item) }));
  sorted.sort((a, b) => b.weight - a.weight);

  plannerResults = new Array(state.plannerItems.length);

  sorted.forEach(item => {
    const weight = item.weight;
    if (weight <= 0) {
      plannerResults[item.origIndex] = { catalogId: item.catalogId, weight: 0, x: 3.5, fit: true };
      return;
    }

    const cat = WEIGHT_CATALOG[item.catalogId];
    const density = cat ? cat.density : CONFIG.densityTungsten;
    const embedded = cat ? cat.embed : true;

    // Effective weight accounts for wood displacement
    let effectiveWeight = weight;
    if (embedded && density > 0) {
      effectiveWeight = weight - (weight / density) * woodDensity;
    }

    // Solve for optimal x: targetCogX = (currentCogX * currentTotal + wx * effectiveWeight) / (currentTotal + effectiveWeight)
    const optimalWx = effectiveWeight > 0
      ? (targetCogX * (currentTotal + effectiveWeight) - currentCogX * currentTotal) / effectiveWeight
      : 0;
    const optimalXFromFront = Math.max(0.5, Math.min(length - 0.5, optimalWx + halfL));

    // Check body fit
    const vExt = getWeightVerticalExtent(item.catalogId, weight);
    const lExt = getWeightLengthExtent(item.catalogId, weight);
    let fits = true;
    if (embedded) {
      const startX = Math.max(0, optimalXFromFront - lExt / 2);
      const endX = Math.min(length, optimalXFromFront + lExt / 2);
      for (let s = 0; s <= 3; s++) {
        const sx = startX + (endX - startX) * (s / 3);
        if (getProfileHeight(sx) < vExt) { fits = false; break; }
      }
    }

    plannerResults[item.origIndex] = { catalogId: item.catalogId, weight, x: optimalXFromFront, fit: fits };

    // Update running totals for next iteration
    currentTotal += weight;
    currentCogX = (currentCogX * (currentTotal - weight) + (optimalXFromFront - halfL) * effectiveWeight) / (currentTotal - weight + effectiveWeight);
  });

  renderPlanner();
}

function applyPlacements() {
  if (plannerResults.length === 0) return;

  plannerResults.forEach((r, i) => {
    if (r.weight <= 0) return;
    const cat = WEIGHT_CATALOG[r.catalogId];
    const type = cat ? (cat.cat === 'cube' ? 'tungsten' : cat.cat === 'rod' ? 'tungsten_cylinder' : cat.cat === 'bb' ? 'steel_bbs' : cat.cat === 'lead' ? 'lead_strip' : 'custom') : 'custom';
    const embedded = cat ? cat.embed : false;
    const obj = { id: state.nextId++, name: cat ? cat.name : 'Planned weight', type, weight: r.weight, x: r.x, y: 0, embedded, catalogId: r.catalogId };
    if (cat && cat.shape === 'cyl' && cat.dims) {
      obj.diameter = cat.dims.d;
      obj.rodLength = cat.dims.l;
    }
    state.weights.push(obj);
  });

  // Clear planner
  state.plannerItems = [];
  plannerResults = [];
  renderPlanner();
  rebuildAll();
}

function quickFillRemaining() {
  // Shortcut: fill remaining budget with a single weight, placed optimally
  applyAutoWeight();
}

function rebuildAll() {
  buildCar();
  renderWeightList();
  updateWeightDisplay();
  updateAutoWeightDisplay();
  renderPlanner();
  updateRules();
  saveState();
}

// ===== DESIGN LIBRARY (localStorage) =====
const LIBRARY_KEY = 'pinewood-derby-cars';

function escapeHtml(str) {
  const div = document.createElement('div');
  div.textContent = str;
  return div.innerHTML;
}

function getDesignLibrary() {
  try {
    return JSON.parse(localStorage.getItem(LIBRARY_KEY)) || [];
  } catch (e) { return []; }
}

function saveDesignLibrary(lib) {
  try {
    localStorage.setItem(LIBRARY_KEY, JSON.stringify(lib));
  } catch (e) { /* storage full */ }
}

function snapshotState() {
  const snap = JSON.parse(JSON.stringify(state));
  delete snap.currentDesignId;
  return snap;
}

function applyParsedState(parsed) {
  if (parsed._v && parsed._v >= 9 && parsed._v < STATE_VERSION) {
    parsed = migrateState(parsed);
  }
  if (parsed._v !== STATE_VERSION) {
    Object.assign(state, DEFAULTS, parsed, {
      _v: STATE_VERSION,
      body: { ...DEFAULTS.body, ...(parsed.body || {}) },
      axles: { ...DEFAULTS.axles, ...(parsed.axles || {}) },
    });
  } else {
    Object.assign(state, parsed, {
      body: { ...DEFAULTS.body, ...(parsed.body || {}) },
      axles: {
        fl: { ...DEFAULTS.axles.fl, ...((parsed.axles || {}).fl || {}) },
        fr: { ...DEFAULTS.axles.fr, ...((parsed.axles || {}).fr || {}) },
        rl: { ...DEFAULTS.axles.rl, ...((parsed.axles || {}).rl || {}) },
        rr: { ...DEFAULTS.axles.rr, ...((parsed.axles || {}).rr || {}) },
      },
      weights: parsed.weights || [],
      plannerItems: parsed.plannerItems || [],
    });
  }
}

function saveDesign() {
  const nameInput = document.getElementById('design-name-input');
  const name = (nameInput.value || '').trim() || 'Untitled';
  state.configName = name;
  document.getElementById('config-name-display').textContent = state.configName;
  const lib = getDesignLibrary();
  if (state.currentDesignId) {
    const idx = lib.findIndex(d => d.id === state.currentDesignId);
    if (idx !== -1) {
      lib[idx].name = name;
      lib[idx].state = snapshotState();
      lib[idx].savedAt = new Date().toISOString();
      saveDesignLibrary(lib);
      saveState();
      showSaveConfirmation();
      renderDesignsList();
      return;
    }
  }
  const id = crypto.randomUUID ? crypto.randomUUID() : Date.now().toString(36) + Math.random().toString(36).slice(2);
  state.currentDesignId = id;
  lib.push({ id, name, savedAt: new Date().toISOString(), state: snapshotState() });
  saveDesignLibrary(lib);
  saveState();
  showSaveConfirmation();
  renderDesignsList();
}

function loadDesign(id) {
  const lib = getDesignLibrary();
  const entry = lib.find(d => d.id === id);
  if (!entry) return;
  applyParsedState(entry.state);
  state.currentDesignId = id;
  state.configName = entry.name;
  document.getElementById('design-name-input').value = entry.name;
  saveState();
  restoreUI();
  rebuildAll();
  renderDesignsList();
}

function deleteDesign(id, event) {
  event.stopPropagation();
  if (!confirm('Delete this design?')) return;
  let lib = getDesignLibrary();
  lib = lib.filter(d => d.id !== id);
  saveDesignLibrary(lib);
  if (state.currentDesignId === id) {
    state.currentDesignId = null;
  }
  saveState();
  renderDesignsList();
}

function newDesign() {
  if (!confirm('Start a new design? Unsaved changes to the current design will be lost.')) return;
  Object.assign(state, JSON.parse(JSON.stringify(DEFAULTS)));
  state.currentDesignId = null;
  saveState();
  restoreUI();
  rebuildAll();
  renderDesignsList();
  closeDesignsModal();
}

function openDesignsModal() {
  document.getElementById('design-name-input').value = state.configName || '';
  renderDesignsList();
  document.getElementById('designs-backdrop').classList.add('open');
}

function closeDesignsModal() {
  document.getElementById('designs-backdrop').classList.remove('open');
}

function openRulesModal() {
  updateRules();
  document.getElementById('rules-backdrop').classList.add('open');
}

function closeRulesModal() {
  document.getElementById('rules-backdrop').classList.remove('open');
}

function renderDesignsList() {
  const lib = getDesignLibrary().sort((a, b) => new Date(b.savedAt) - new Date(a.savedAt));
  const container = document.getElementById('designs-list');
  if (lib.length === 0) {
    container.innerHTML = '<div class="designs-empty"><span>&#9881;</span>No saved designs yet.<br>Click <b>Save</b> to store your first design.</div>';
    return;
  }
  container.innerHTML = lib.map(d => {
    const active = d.id === state.currentDesignId ? ' active' : '';
    const date = new Date(d.savedAt).toLocaleString();
    const wCount = (d.state && d.state.weights) ? d.state.weights.length : 0;
    return `<div class="design-item${active}" onclick="loadDesign('${d.id}')">
      <div class="design-item-info">
        <div class="design-item-name">${escapeHtml(d.name)}${active ? ' <span style="color:var(--green);font-size:0.75rem">&#10003; active</span>' : ''}</div>
        <div class="design-item-meta">${escapeHtml(date)} // ${wCount} weight${wCount !== 1 ? 's' : ''}</div>
      </div>
      <button class="design-item-delete" onclick="deleteDesign('${d.id}', event)" title="Delete">DEL</button>
    </div>`;
  }).join('');
}

function showSaveConfirmation() {
  const btn = document.getElementById('save-btn');
  const orig = btn.textContent;
  btn.textContent = '\u2713 Saved';
  btn.classList.add('saved');
  setTimeout(() => {
    btn.textContent = orig;
    btn.classList.remove('saved');
  }, 1200);
}

function exportCurrentDesign() {
  const json = JSON.stringify(snapshotState(), null, 2);
  const blob = new Blob([json], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = (state.configName || 'Untitled') + '.json';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

function importDesignFromFile(input) {
  const file = input.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = function(e) {
    try {
      const parsed = JSON.parse(e.target.result);
      applyParsedState(parsed);
      state.currentDesignId = null;
      state.configName = parsed.configName || file.name.replace(/\.json$/i, '');
      document.getElementById('config-name-display').textContent = state.configName;
      saveState();
      restoreUI();
      rebuildAll();
      closeDesignsModal();
    } catch (err) {
      alert('Failed to load config: ' + err.message);
    }
  };
  reader.readAsText(file);
  input.value = '';
}

// Close designs modal on Escape
document.addEventListener('keydown', function(e) {
  if (e.key === 'Escape') { closeDesignsModal(); closeRulesModal(); }
});

// ===== TABS =====
function switchTab(name, btn) {
  document.querySelectorAll('.tabs button').forEach(b => b.classList.remove('active'));
  document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));
  document.getElementById('tab-' + name).classList.add('active');
  btn.classList.add('active');
}

// ===== RENDER LOOP =====
let time = 0;
function animate() {
  requestAnimationFrame(animate);
  time += 0.016;

  const rect = canvas.parentElement.getBoundingClientRect();
  if (canvas.width !== rect.width || canvas.height !== rect.height) {
    renderer.setSize(rect.width, rect.height);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    camera.aspect = rect.width / rect.height;
    camera.updateProjectionMatrix();
  }

  // Gentle auto-rotate
  if (autoRotate) {
    spherical.theta += 0.002;
    updateCameraFromSpherical();
  }

  // Pulsing CoG marker
  if (cogMarker) {
    cogMarker.material.emissiveIntensity = 0.5 + Math.sin(time * 3) * 0.3;
  }

  renderer.render(scene, camera);
}

// ===== INIT =====
// Restore saved state into UI inputs
function restoreUI() {
  // Config name
  document.getElementById('config-name-display').textContent = state.configName || 'BSA BLOCK';

  // Body sliders
  const bodySliders = {
    noseHeight: document.querySelector('#tab-body input[type="range"][oninput*="noseHeight"]'),
    frontHeight: document.querySelector('#tab-body input[type="range"][oninput*="frontHeight"]'),
    scoopDepth: document.querySelector('#tab-body input[type="range"][oninput*="scoopDepth"]'),
    rearHeight: document.querySelector('#tab-body input[type="range"][oninput*="rearHeight"]'),
    tailHeight: document.querySelector('#tab-body input[type="range"][oninput*="tailHeight"]'),
  };
  for (const [key, slider] of Object.entries(bodySliders)) {
    if (slider) {
      slider.value = state.body[key];
      const valEl = document.getElementById('val-' + key);
      if (valEl) valEl.textContent = state.body[key].toFixed(2) + '"';
    }
  }

  // Raw wood weight
  document.getElementById('raw-wood-weight').value = state.rawWoodWeight.toFixed(2);

  // Wheel + Axle weight
  document.getElementById('wheel-axle-weight').value = state.wheelAxleWeight.toFixed(2);

  // Axle mount type
  document.getElementById('axle-mount-type').value = state.axleMountType;
  document.getElementById('drilled-options').style.display = state.axleMountType === 'drilled' ? 'block' : 'none';
  document.getElementById('slot-info').style.display = state.axleMountType === 'slot' ? 'block' : 'none';
  // Clamp drilled height to safe range on restore
  const maxH = CONFIG.wheelDiameter / 2 - CONFIG.minClearance;
  state.drilledAxleHeight = Math.min(state.drilledAxleHeight, maxH);
  document.getElementById('drilled-height-slider').value = state.drilledAxleHeight;
  document.getElementById('val-drilled-height').textContent = state.drilledAxleHeight.toFixed(3) + '"';
  const clr = CONFIG.wheelDiameter / 2 - state.drilledAxleHeight;
  document.getElementById('val-drilled-clearance').textContent = clr.toFixed(3) + '"';
  document.getElementById('val-drilled-clearance').style.color = clr >= CONFIG.minClearance ? 'var(--green)' : 'var(--race-red)';
  document.getElementById('val-slot-height').textContent = CONFIG.axleSlotHeight.toFixed(3) + '"';

  // Axle controls
  for (const [key, ax] of Object.entries(state.axles)) {
    const bendEl = document.getElementById(`ax-${key}-bend`);
    const camberEl = document.getElementById(`ax-${key}-camber`);
    const raisedEl = document.getElementById(`ax-${key}-raised`);
    if (bendEl) bendEl.textContent = ax.bend.toFixed(1) + '°';
    if (camberEl) camberEl.textContent = ax.camber.toFixed(1) + '°';
    if (raisedEl) raisedEl.checked = ax.raised;
    const parent = bendEl && bendEl.closest('.axle-wheel');
    if (parent) {
      const sliders = parent.querySelectorAll('input[type="range"]');
      if (sliders[0]) sliders[0].value = ax.bend;
      if (sliders[1]) sliders[1].value = ax.camber;
    }
  }

  // Misc weight
  document.getElementById('misc-weight').value = (state.miscWeight || 0).toFixed(2);
  document.getElementById('misc-weight-x').value = state.miscWeightX || 3.5;
  document.getElementById('misc-weight-x-val').textContent = (state.miscWeightX || 3.5).toFixed(1) + '"';
  document.getElementById('misc-weight-x-row').style.display = (state.miscWeight || 0) > 0 ? '' : 'none';

  // Planner
  initPlannerDropdowns();
}
restoreUI();
rebuildAll();
animate();
</script>
</body>
</html>
